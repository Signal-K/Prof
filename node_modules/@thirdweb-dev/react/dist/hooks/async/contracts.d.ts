import { ContractAddress, RequiredParam } from "../../types";
import { SmartContract } from "@thirdweb-dev/sdk";
import type { PublishedMetadata } from "@thirdweb-dev/sdk/dist/src/schema/contracts/custom";
/**
 *
 * @internal
 *
 * @param contractAddress - contract address
 * @returns the contract abi
 */
export declare function useContractAbi(contractAddress: RequiredParam<ContractAddress>): {
    abi: null;
    data: undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: true;
    isRefetchError: false;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    abi: null;
    data: undefined;
    error: null;
    isError: false;
    isLoading: true;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: false;
    status: "loading";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    abi: {
        [x: string]: any;
        name: string;
        type: string;
        outputs: {
            [x: string]: any;
            name: string;
            type: string;
        }[];
        inputs: {
            [x: string]: any;
            name: string;
            type: string;
        }[];
    }[] | null;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: true;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    abi: {
        [x: string]: any;
        name: string;
        type: string;
        outputs: {
            [x: string]: any;
            name: string;
            type: string;
        }[];
        inputs: {
            [x: string]: any;
            name: string;
            type: string;
        }[];
    }[] | null;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: null;
    isError: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: true;
    status: "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
};
/**
 * Use this to get the contract type for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractType, isLoading, error } = useContractType("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract type of the contract
 * @beta
 */
export declare function useContractType(contractAddress: RequiredParam<ContractAddress>): import("react-query").UseQueryResult<"split" | "custom" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined, unknown>;
/**
 * Use this to get the publish metadata for a deployed contract.
 *
 * @example
 * ```javascript
 * const { data: publishMetadata, isLoading, error } = useContractPublishMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the published metadata (name, abi, bytecode) of the contract
 * @beta
 */
export declare function useContractPublishMetadata(contractAddress: RequiredParam<ContractAddress>): import("react-query").UseQueryResult<PublishedMetadata | undefined, unknown>;
/**
 * Use this resolve a contract address to a thirdweb (built-in / custom) contract instance.
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract once it is resolved
 * @beta
 */
export declare function useContract(contractAddress: RequiredParam<ContractAddress>): {
    contract: null;
    data: undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: true;
    isRefetchError: false;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    contract: null;
    data: undefined;
    error: null;
    isError: false;
    isLoading: true;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: false;
    status: "loading";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    contract: SmartContract<any> | null;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: true;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    contract: SmartContract<any> | null;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined;
    error: null;
    isError: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: true;
    status: "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        publishMetadata: null;
    } | {
        contractType: "custom";
        publishMetadata: PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
};
/**
 * Use this to get the contract metadata for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractMetadata, isLoading, error } = useContractMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract metadata of the deployed contract
 * @beta
 */
export declare function useContractMetadata(contractAddress: RequiredParam<ContractAddress>): import("react-query").UseQueryResult<{
    [x: string]: import("@thirdweb-dev/sdk").Json;
    description?: string | undefined;
    image?: any;
    external_link?: string | undefined;
    name: string;
}, unknown>;
/**
 @internal
 */
export declare function useContractFunctions(contractAddress: RequiredParam<ContractAddress>): import("react-query").UseQueryResult<import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").AbiFunction[] | null, unknown>;
