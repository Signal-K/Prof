{"version":3,"sources":["../src/connectors/gnosis-safe.ts","../src/connectors/magic.ts","../src/constants/chain.ts","../src/hooks/useSigner.ts","../src/Provider.tsx","../src/hooks/contracts/useBuiltinContract.ts","../src/hooks/contracts/useEditionDrop.ts","../src/hooks/contracts/useEdition.ts","../src/hooks/contracts/useNFTDrop.ts","../src/hooks/contracts/useMarketplace.ts","../src/hooks/contracts/useNFTCollection.ts","../src/hooks/contracts/usePack.ts","../src/hooks/contracts/useToken.ts","../src/hooks/contracts/useTokenDrop.ts","../src/hooks/contracts/useVote.ts","../src/hooks/contracts/useSplit.ts","../src/hooks/useConnect.ts","../src/hooks/useDisconnect.ts","../src/hooks/useAddress.ts","../src/hooks/useReadonlySDK.ts","../src/utils/isMobile.ts","../src/hooks/connectors/useMetamask.ts","../src/hooks/connectors/useWalletConnect.ts","../src/hooks/connectors/useWalletLink.ts","../src/hooks/connectors/useGnosis.ts","../src/hooks/connectors/useMagic.ts","../src/hooks/useChainId.ts","../src/hooks/useNetworkMismatch.ts","../src/hooks/useNetwork.ts","../src/index.ts","../src/constants/ipfs.ts","../src/utils/ipfs.ts","../src/utils/media.ts","../src/utils/react.ts","../src/components/Icons.tsx","../src/components/MediaRenderer.tsx","../src/components/NftMedia.tsx","../src/utils/cache-keys.ts","../src/hooks/query-utils/useQueryWithNetwork.ts","../src/hooks/async/contracts.ts","../src/hooks/async/nft.ts","../src/hooks/async/drop.ts","../src/hooks/async/marketplace.ts","../src/hooks/async/token.ts","../src/hooks/async/claim-conditions.ts","../src/hooks/async/wallet.ts"],"sourcesContent":["import { ChainId } from \"@thirdweb-dev/sdk\";\nimport { Signer, ethers, utils } from \"ethers\";\nimport invariant from \"tiny-invariant\";\nimport { Chain, Connector, ConnectorData, normalizeChainId } from \"wagmi\";\n\nconst CHAIN_ID_TO_GNOSIS_SERVER_URL = {\n  [ChainId.Mainnet]: \"https://safe-transaction.mainnet.gnosis.io\",\n  [ChainId.Avalanche]: \"https://safe-transaction.avalanche.gnosis.io\",\n  [ChainId.Polygon]: \"https://safe-transaction.polygon.gnosis.io\",\n  [ChainId.Goerli]: \"https://safe-transaction.goerli.gnosis.io\",\n  [ChainId.Rinkeby]: \"https://safe-transaction.rinkeby.gnosis.io\",\n};\n\nexport interface GnosisConnectorArguments {\n  safeAddress: string;\n  safeChainId: number;\n}\n\nconst __IS_SERVER__ = typeof window === \"undefined\";\n\nexport class GnosisSafeConnector extends Connector {\n  id = \"gnosis\";\n  ready = __IS_SERVER__;\n  name = \"Gnosis Safe\";\n  // config\n  public previousConnector?: Connector<any>;\n  private config?: GnosisConnectorArguments;\n  private safeSigner?: Signer;\n\n  constructor(config: { chains?: Chain[] }) {\n    // filter out any chains that gnosis doesnt support before passing to connector\n    config.chains = config.chains?.filter(\n      (c) => c.id in CHAIN_ID_TO_GNOSIS_SERVER_URL,\n    );\n    super({ ...config, options: undefined });\n\n    if (!__IS_SERVER__) {\n      this.ready = true;\n    }\n  }\n\n  async connect(): Promise<ConnectorData<any>> {\n    this.safeSigner = await this.createSafeSigner();\n    const account = await this.getAccount();\n    const provider = await this.getProvider();\n    const id = await this.getChainId();\n    return {\n      account,\n      provider,\n      chain: { id, unsupported: this.isChainUnsupported(id) },\n    };\n  }\n\n  private async createSafeSigner() {\n    const signer = await this.previousConnector?.getSigner();\n    const safeAddress = this.config?.safeAddress;\n    const safeChainId = this.config\n      ?.safeChainId as keyof typeof CHAIN_ID_TO_GNOSIS_SERVER_URL;\n    invariant(\n      signer,\n      \"cannot create Gnosis Safe signer without a personal signer\",\n    );\n    const signerChainId = await signer.getChainId();\n    invariant(\n      signerChainId === safeChainId,\n      \"chainId of personal signer has to match safe chainId\",\n    );\n    invariant(\n      safeAddress,\n      \"safeConfig.safeAddress is required, did you forget to call setSafeConfig?\",\n    );\n    invariant(\n      safeChainId,\n      \"safeConfig.safeChainId is required, did you forget to call setSafeConfig?\",\n    );\n    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];\n    invariant(serverUrl, \"Chain not supported\");\n\n    const [safeEthersAdapters, safeCoreSdk, safeEthersLib] = await Promise.all([\n      import(\"@gnosis.pm/safe-ethers-adapters\"),\n      import(\"@gnosis.pm/safe-core-sdk\"),\n      import(\"@gnosis.pm/safe-ethers-lib\"),\n    ]);\n\n    const ethAdapter = new safeEthersLib.default({ ethers, signer });\n    const safe = await safeCoreSdk.default.create({\n      ethAdapter,\n      safeAddress,\n    });\n    const service = new safeEthersAdapters.SafeService(serverUrl);\n    return new safeEthersAdapters.SafeEthersSigner(\n      safe,\n      service,\n      signer.provider,\n    );\n  }\n\n  async disconnect(): Promise<void> {\n    this.config = undefined;\n    this.safeSigner = undefined;\n    this.previousConnector = undefined;\n    return undefined;\n  }\n\n  async getAccount(): Promise<string> {\n    const signer = await this.getSigner();\n    return await signer.getAddress();\n  }\n\n  async getChainId(): Promise<number> {\n    return (await this.getSigner()).getChainId();\n  }\n\n  async getProvider() {\n    return (await this.getSigner()).provider;\n  }\n\n  async getSigner(): Promise<Signer> {\n    if (!this.safeSigner) {\n      this.safeSigner = await this.createSafeSigner();\n    }\n    return this.safeSigner;\n  }\n\n  async isAuthorized(): Promise<boolean> {\n    try {\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  protected onAccountsChanged(accounts: string[]) {\n    if (accounts.length === 0) {\n      this.emit(\"disconnect\");\n    } else {\n      this.emit(\"change\", { account: utils.getAddress(accounts[0]) });\n    }\n  }\n\n  protected override isChainUnsupported(chainId: number) {\n    return this.config?.safeChainId\n      ? chainId === this.config.safeChainId\n      : false;\n  }\n\n  protected onChainChanged(chainId: string | number) {\n    const id = normalizeChainId(chainId);\n    const unsupported = this.isChainUnsupported(id);\n    this.emit(\"change\", { chain: { id, unsupported } });\n  }\n\n  protected onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n\n  public setConfiguration(\n    connector: Connector<any>,\n    config: GnosisConnectorArguments,\n  ) {\n    this.previousConnector = connector;\n    this.config = config;\n  }\n}\n","import { providers, utils } from \"ethers\";\nimport type {\n  LoginWithMagicLinkConfiguration,\n  Magic as MagicInstance,\n  MagicSDKAdditionalConfiguration,\n} from \"magic-sdk\";\nimport invariant from \"tiny-invariant\";\nimport { Chain, Connector, normalizeChainId } from \"wagmi\";\n\nexport interface MagicConnectorArguments\n  extends MagicSDKAdditionalConfiguration {\n  apiKey: string;\n  doNotAutoConnect?: boolean;\n  rpcUrls: Record<number, string>;\n}\n\nconst __IS_SERVER__ = typeof window === \"undefined\";\n\nexport class MagicConnector extends Connector {\n  readonly id = \"magic\";\n  readonly name = \"Magic\";\n  readonly ready = __IS_SERVER__;\n\n  override options: MagicConnectorArguments;\n  private configuration?: LoginWithMagicLinkConfiguration;\n  public magic?: MagicInstance;\n\n  getConfiguration() {\n    if (__IS_SERVER__) {\n      return undefined;\n    }\n\n    const config = window.localStorage.getItem(\"-magic-link:configuration\");\n    if (config) {\n      this.configuration = JSON.parse(config);\n    }\n    return this.configuration;\n  }\n\n  constructor(config: { chains?: Chain[]; options: MagicConnectorArguments }) {\n    super({ ...config, options: config?.options });\n    this.options = config.options;\n\n    if (!__IS_SERVER__) {\n      this.ready = true;\n      if (this.options.doNotAutoConnect || !this.getConfiguration()) {\n        return;\n      }\n      this.connect(true);\n    }\n  }\n\n  async connect(isAutoConnect?: true) {\n    const { apiKey, doNotAutoConnect, rpcUrls, ...options } = this.options;\n    const configuration = this.getConfiguration();\n\n    try {\n      invariant(\n        configuration,\n        \"did you forget to set the configuration via: setConfiguration()?\",\n      );\n      if (isAutoConnect) {\n        configuration.showUI = false;\n      }\n\n      return import(\"magic-sdk\").then(async (m) => {\n        this.magic = new m.Magic(apiKey, options);\n\n        await this.magic.auth.loginWithMagicLink(configuration);\n        const provider = this.getProvider();\n        if (provider.on) {\n          provider.on(\"accountsChanged\", this.onAccountsChanged);\n          provider.on(\"chainChanged\", this.onChainChanged);\n          provider.on(\"disconnect\", this.onDisconnect);\n        }\n        const account = await this.getAccount();\n        const id = await this.getChainId();\n        return {\n          account,\n          provider,\n          chain: { id, unsupported: this.isChainUnsupported(id) },\n        };\n      });\n    } catch (e) {\n      if (!isAutoConnect) {\n        throw e;\n      }\n      return {\n        account: undefined,\n        provider: undefined,\n        chain: undefined,\n      };\n    }\n  }\n  async disconnect() {\n    const provider = this.getProvider();\n    if (provider?.removeListener) {\n      provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n      provider.removeListener(\"chainChanged\", this.onChainChanged);\n      provider.removeListener(\"disconnect\", this.onDisconnect);\n    }\n    this.setConfiguration(undefined);\n  }\n\n  override async switchChain(chainId: number) {\n    invariant(!this.isChainUnsupported(chainId), \"chain is not supported\");\n    const provider = this.getProvider();\n    if (provider?.removeListener) {\n      provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n      provider.removeListener(\"chainChanged\", this.onChainChanged);\n      provider.removeListener(\"disconnect\", this.onDisconnect);\n    }\n\n    this.options.network = {\n      chainId,\n      rpcUrl: this.options.rpcUrls[chainId],\n    };\n    await this.connect();\n    this.onChainChanged(chainId);\n    return this.chains.find((c) => c.id === chainId);\n  }\n\n  async getAccount() {\n    const signer = await this.getSigner();\n    return await signer.getAddress();\n  }\n  async getChainId() {\n    const signer = await this.getSigner();\n    return await signer.getChainId();\n  }\n  getProvider() {\n    invariant(this.magic, \"connector is not initialized\");\n    return new providers.Web3Provider(\n      this.magic.rpcProvider as unknown as providers.ExternalProvider,\n    );\n  }\n  async getSigner() {\n    if (!this.magic) {\n      await this.connect();\n    }\n    return this.getProvider().getSigner();\n  }\n  async isAuthorized() {\n    try {\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  protected onAccountsChanged(accounts: string[]) {\n    if (accounts.length === 0) {\n      this.emit(\"disconnect\");\n    } else {\n      this.emit(\"change\", { account: utils.getAddress(accounts[0]) });\n    }\n  }\n\n  protected override isChainUnsupported(chainId: number) {\n    return !this.chains.some((x) => x.id === chainId);\n  }\n\n  protected onChainChanged(chainId: string | number) {\n    const id = normalizeChainId(chainId);\n    const unsupported = this.isChainUnsupported(id);\n    this.emit(\"change\", { chain: { id, unsupported } });\n  }\n\n  protected onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n\n  public setConfiguration(configuration?: LoginWithMagicLinkConfiguration) {\n    if (configuration) {\n      this.configuration = configuration;\n      window.localStorage.setItem(\n        \"-magic-link:configuration\",\n        JSON.stringify(configuration),\n      );\n    } else {\n      this.configuration = undefined;\n      window.localStorage.removeItem(\"-magic-link:configuration\");\n    }\n  }\n}\n","import { ChainId } from \"@thirdweb-dev/sdk\";\nimport type { Chain as WagmiChain } from \"wagmi\";\n\nexport type Chain = WagmiChain;\n\nconst chain = {\n  mainnet: {\n    id: ChainId.Mainnet,\n    name: \"Mainnet\",\n    nativeCurrency: {\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://etherscan.io\",\n      },\n    ],\n  },\n  rinkeby: {\n    id: ChainId.Rinkeby,\n    name: \"Rinkeby\",\n    nativeCurrency: {\n      name: \"Rinkeby Ether\",\n      symbol: \"rETH\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://rinkeby.etherscan.io\",\n      },\n    ],\n    testnet: true,\n  },\n  goerli: {\n    id: ChainId.Goerli,\n    name: \"Goerli\",\n    nativeCurrency: {\n      name: \"Goerli Ether\",\n      symbol: \"gETH\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\"],\n    blockExplorers: [\n      {\n        name: \"Etherscan\",\n        url: \"https://goerli.etherscan.io\",\n      },\n    ],\n    testnet: true,\n  },\n  polygonMainnet: {\n    id: ChainId.Polygon,\n    name: \"Polygon Mainnet\",\n    nativeCurrency: {\n      name: \"Matic\",\n      symbol: \"MATIC\",\n      decimals: 18,\n    },\n    rpcUrls: [\n      \"https://polygon-rpc.com\",\n      \"https://rpc-mainnet.matic.network\",\n      \"https://matic-mainnet.chainstacklabs.com\",\n      \"https://rpc-mainnet.maticvigil.com\",\n      \"https://rpc-mainnet.matic.quiknode.pro\",\n      \"https://matic-mainnet-full-rpc.bwarelabs.com\",\n    ],\n    blockExplorers: [\n      {\n        name: \"Polygonscan\",\n        url: \"https://polygonscan.com\",\n      },\n    ],\n  },\n  polygonTestnetMumbai: {\n    id: ChainId.Mumbai,\n    name: \"Polygon Testnet Mumbai\",\n    nativeCurrency: {\n      name: \"Matic\",\n      symbol: \"MATIC\",\n      decimals: 18,\n    },\n    rpcUrls: [\n      \"https://matic-mumbai.chainstacklabs.com\",\n      \"https://rpc-mumbai.maticvigil.com\",\n      \"https://matic-testnet-archive-rpc.bwarelabs.com\",\n    ],\n    blockExplorers: [\n      {\n        name: \"Polygonscan\",\n        url: \"https://mumbai.polygonscan.com\",\n      },\n    ],\n    testnet: true,\n  },\n  avalanche: {\n    id: ChainId.Avalanche,\n    name: \"Avalanche\",\n    nativeCurrency: {\n      name: \"AVAX\",\n      symbol: \"AVAX\",\n      decimals: 18,\n    },\n    rpcUrls: [\n      \"https://api.avax.network/ext/bc/C/rpc\",\n      \"https://rpc.ankr.com/avalanche\",\n    ],\n    blockExplorers: [\n      {\n        name: \"SnowTrace\",\n        url: \"https://snowtrace.io/\",\n      },\n    ],\n    testnet: false,\n  },\n  // avalancheFuji: {\n  //   id: 43113,\n  //   name: \"Avalanche FUJI\",\n  //   nativeCurrency: {\n  //     name: \"AVAX\",\n  //     symbol: \"AVAX\",\n  //     decimals: 18,\n  //   },\n  //   rpcUrls: [\"https://api.avax-test.network/ext/bc/C/rpc\"],\n  //   blockExplorers: [\n  //     {\n  //       name: \"SnowTrace\",\n  //       url: \"https://testnet.snowtrace.io/\",\n  //     },\n  //   ],\n  //   testnet: true,\n  // },\n  // custom added (non wagmi standard)\n  fantom: {\n    id: ChainId.Fantom,\n    name: \"Fantom Opera\",\n    nativeCurrency: {\n      name: \"Fantom\",\n      symbol: \"FTM\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://rpc.ftm.tools\"],\n    blockExplorerUrls: [\n      {\n        name: \"FTMScan\",\n        url: \"https://ftmscan.com/\",\n      },\n    ],\n    testnet: false,\n  },\n} as const;\n\nexport const defaultSupportedChains = Object.values(chain);\n\nexport type SupportedChainId = typeof defaultSupportedChains[number][\"id\"];\n\nexport type SupportedChain = SupportedChainId | Chain;\n","import { Signer } from \"ethers\";\nimport { useEffect, useRef } from \"react\";\nimport { useAccount, useNetwork, useSigner as useWagmiSigner } from \"wagmi\";\n\n/**\n *\n * @internal\n */\nexport function useSigner() {\n  const [signer, getSigner] = useWagmiSigner();\n  const [account] = useAccount();\n  const [network] = useNetwork();\n\n  const _getSignerPromise = useRef<ReturnType<typeof getSigner> | null>(null);\n\n  const address = account.data?.address;\n  const chainId = network.data.chain?.id;\n\n  const previousAddress = usePrevious(account.data?.address);\n  const previousChainId = usePrevious(network.data?.chain?.id);\n\n  useEffect(() => {\n    if (address !== previousAddress || chainId !== previousChainId) {\n      if (!_getSignerPromise.current) {\n        return;\n      } else {\n        _getSignerPromise.current = getSigner().finally(() => {\n          _getSignerPromise.current = null;\n        });\n      }\n    }\n  }, [address, chainId, previousAddress, previousChainId]);\n\n  return Signer.isSigner(signer.data) ? signer.data : undefined;\n}\n\nfunction usePrevious<TVal>(value: TVal): TVal | undefined {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = useRef<TVal>();\n  // Store current value in ref\n  useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n  // Return previous value (happens before update in useEffect above)\n  return ref.current;\n}\n","import {\n  GnosisConnectorArguments,\n  GnosisSafeConnector,\n} from \"./connectors/gnosis-safe\";\nimport { MagicConnector, MagicConnectorArguments } from \"./connectors/magic\";\nimport {\n  Chain,\n  SupportedChain,\n  SupportedChainId,\n  defaultSupportedChains,\n} from \"./constants/chain\";\nimport { useSigner } from \"./hooks/useSigner\";\nimport {\n  ChainId,\n  ChainOrRpc,\n  IStorage,\n  SDKOptions,\n  SUPPORTED_CHAIN_ID,\n  SignerOrProvider,\n  ThirdwebSDK,\n} from \"@thirdweb-dev/sdk\";\nimport { Signer } from \"ethers\";\nimport React, { createContext, useEffect, useMemo } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"react-query\";\nimport invariant from \"tiny-invariant\";\nimport {\n  WagmiProvider,\n  ProviderProps as WagmiproviderProps,\n  useProvider,\n} from \"wagmi\";\nimport { CoinbaseWalletConnector } from \"wagmi/connectors/coinbaseWallet\";\nimport { InjectedConnector } from \"wagmi/connectors/injected\";\nimport { WalletConnectConnector } from \"wagmi/connectors/walletConnect\";\n\n/**\n * @internal\n */\nexport type InjectedConnectorType =\n  | \"injected\"\n  | \"metamask\"\n  | { name: \"injected\" | \"metamask\"; options?: InjectedConnector[\"options\"] };\n\n/**\n * @internal\n */\nexport type WalletConnectConnectorType =\n  | \"walletConnect\"\n  | { name: \"walletConnect\"; options: WalletConnectConnector[\"options\"] };\n\n/**\n * @internal\n */\nexport type WalletLinkConnectorType =\n  | \"walletLink\"\n  | \"coinbase\"\n  | {\n      name: \"walletLink\" | \"coinbase\";\n      options: CoinbaseWalletConnector[\"options\"];\n    };\n\n/**\n * @internal\n */\nexport type MagicConnectorType =\n  | \"magic\"\n  | {\n      name: \"magic\";\n      options: Omit<MagicConnectorArguments, \"network\">;\n    };\n\n/**\n * @internal\n */\nexport type GnosisConnectorType =\n  | \"gnosis\"\n  | {\n      name: \"gnosis\";\n      options: GnosisConnectorArguments;\n    };\n\n/**\n * @internal\n */\nexport type WalletConnector =\n  | InjectedConnectorType\n  | WalletConnectConnectorType\n  | WalletLinkConnectorType\n  | MagicConnectorType\n  | GnosisConnectorType;\n\n/**\n * @internal\n */\nexport type ChainRpc<TSupportedChain extends SupportedChain> = Record<\n  TSupportedChain extends Chain ? TSupportedChain[\"id\"] : TSupportedChain,\n  string\n>;\n\n/**\n * the metadata to pass to wallet connection dialog (may show up during the wallet-connection process)\n * @remarks this is only used for wallet connect and wallet link, metamask does not support it\n * @public\n */\nexport interface DAppMetaData {\n  /**\n   * the name of your app\n   */\n  name: string;\n  /**\n   * optional - a description of your app\n   */\n  description?: string;\n  /**\n   * optional - a url that points to a logo (or favicon) of your app\n   */\n  logoUrl?: string;\n  /**\n   * optional - the url where your app is hosted\n   */\n  url?: string;\n  /**\n   * optional - whether to show the connect dialog in darkmode or not\n   */\n  isDarkMode?: boolean;\n}\n\n/**\n * The possible props for the ThirdwebProvider.\n */\nexport interface ThirdwebProviderProps<\n  TSupportedChain extends SupportedChain = SupportedChain,\n> {\n  /**\n   * The {@link SDKOptions | Thirdweb SDK Options} to pass to the thirdweb SDK\n   * comes with sensible defaults\n   */\n  sdkOptions?: SDKOptions;\n  /**\n   * An array of chainIds or {@link Chain} objects that the dApp supports\n   * If not provided, all chains supported by the SDK will be supported by default\n   */\n  supportedChains?: TSupportedChain[];\n  /**\n   * An array of connector types (strings) or wallet connector objects that the dApp supports\n   * If not provided, will default to metamask (injected), wallet connect and walletlink (coinbase wallet) with sensible defaults\n   */\n  walletConnectors?: WalletConnector[];\n  /**\n   * A partial map of chainIds to rpc urls to use for certain chains\n   * If not provided, will default to the rpcUrls of the chain objects for the supported chains\n   */\n  chainRpc?: Partial<ChainRpc<TSupportedChain>>;\n  /**\n   * Metadata to pass to wallet connect and walletlink wallet connect. (Used to show *which* dApp is being connected to in mobile wallets that support it)\n   * Defaults to just the name being passed as `thirdweb powered dApp`.\n   */\n  dAppMeta?: DAppMetaData;\n  /**\n   * The chainId that your dApp is running on.\n   * While this *can* be `undefined` it is required to be passed. Passing `undefined` will cause no SDK to be instantiated.\n   * When passing a chainId, it **must** be part of the `supportedChains` array.\n   */\n  desiredChainId: TSupportedChain extends Chain\n    ? TSupportedChain[\"id\"]\n    : TSupportedChain | undefined;\n\n  /**\n   * The storage interface to use with the sdk.\n   */\n  storageInterface?: IStorage;\n\n  /**\n   * The react-query client to use. (Defaults to a default client.)\n   * @beta\n   */\n  queryClient?: QueryClient;\n\n  /**\n   * Whether or not to attempt auto-connect to a wallet.\n   */\n  autoConnect?: boolean;\n}\n\n// SDK handles this under the hood for us\nconst defaultChainRpc: Record<SupportedChainId, string> = {\n  [ChainId.Mainnet]: \"mainnet\",\n  [ChainId.Rinkeby]: \"rinkeby\",\n  [ChainId.Goerli]: \"goerli\",\n  [ChainId.Polygon]: \"polygon\",\n  [ChainId.Mumbai]: \"mumbai\",\n  [ChainId.Fantom]: \"fantom\",\n  [ChainId.Avalanche]: \"avalanche\",\n};\n\nconst defaultdAppMeta: DAppMetaData = {\n  name: \"thirdweb powered dApp\",\n};\n\nconst defaultWalletConnectors: Required<\n  ThirdwebProviderProps[\"walletConnectors\"]\n> = [\"metamask\", \"walletConnect\", \"walletLink\"];\n\n/**\n *\n * The `<ThirdwebProvider />` component lets you control what networks you want users to connect to, what types of wallets can connect to your app, and the settings for the [Typescript SDK](https://docs.thirdweb.com/typescript).\n *\n * @example\n * You can wrap your application with the provider as follows:\n *\n * ```jsx title=\"App.jsx\"\n * import { ThirdwebProvider, ChainId } from \"@thirdweb-dev/react\";\n *\n * const App = () => {\n *   return (\n *     <ThirdwebProvider desiredChainId={ChainId.Mainnet}>\n *       <YourApp />\n *     </ThirdwebProvider>\n *   );\n * };\n * ```\n *\n * @public\n *\n */\nexport const ThirdwebProvider = <\n  TSupportedChain extends SupportedChain = SupportedChain,\n>({\n  sdkOptions,\n  chainRpc = defaultChainRpc,\n  supportedChains = defaultSupportedChains.map(\n    (c) => c.id,\n  ) as TSupportedChain[],\n  walletConnectors = defaultWalletConnectors,\n  dAppMeta = defaultdAppMeta,\n  desiredChainId,\n  storageInterface,\n  queryClient,\n  autoConnect = true,\n  children,\n}: React.PropsWithChildren<ThirdwebProviderProps<TSupportedChain>>) => {\n  // construct the wagmi options\n\n  const _supporrtedChains = useMemo(() => {\n    return supportedChains\n      .map((c) => {\n        if (typeof c === \"number\") {\n          return defaultSupportedChains.find((sc) => sc.id === c);\n        }\n        return c as Chain;\n      })\n      .filter((c) => c !== undefined) as Chain[];\n  }, [supportedChains]);\n\n  const _rpcUrlMap = useMemo(() => {\n    return _supporrtedChains.reduce((prev, curr) => {\n      prev[curr.id] =\n        curr.id in chainRpc\n          ? chainRpc[curr.id as keyof ChainRpc<TSupportedChain>] ||\n            curr.rpcUrls[0]\n          : curr.rpcUrls[0];\n      return prev;\n    }, {} as Record<number, string>);\n  }, [chainRpc, _supporrtedChains]);\n\n  const wagmiProps: WagmiproviderProps = useMemo(() => {\n    const walletConnectClientMeta = {\n      name: dAppMeta.name,\n      url: dAppMeta.url || \"\",\n      icons: [dAppMeta.logoUrl || \"\"],\n      description: dAppMeta.description || \"\",\n    };\n\n    const walletLinkClientMeta = {\n      appName: dAppMeta.name,\n      appLogoUrl: dAppMeta.logoUrl,\n      darkMode: dAppMeta.isDarkMode,\n    };\n\n    return {\n      autoConnect,\n      connectorStorageKey: \"tw:provider:connectors\",\n      connectors: ({ chainId }: { chainId?: number }) => {\n        return walletConnectors\n          .map((connector) => {\n            // injected connector\n            if (\n              (typeof connector === \"string\" &&\n                (connector === \"injected\" || connector === \"metamask\")) ||\n              (typeof connector === \"object\" &&\n                (connector.name === \"injected\" ||\n                  connector.name === \"metamask\"))\n            ) {\n              return new InjectedConnector({\n                options:\n                  typeof connector === \"string\"\n                    ? { shimDisconnect: true, shimChainChangedDisconnect: true }\n                    : connector.options,\n                chains: _supporrtedChains,\n              });\n            }\n            if (\n              (typeof connector === \"string\" &&\n                connector === \"walletConnect\") ||\n              (typeof connector === \"object\" &&\n                connector.name === \"walletConnect\")\n            ) {\n              return new WalletConnectConnector({\n                options:\n                  typeof connector === \"string\"\n                    ? {\n                        chainId,\n                        rpc: _rpcUrlMap,\n                        clientMeta: walletConnectClientMeta,\n                        qrcode: true,\n                      }\n                    : {\n                        chainId,\n                        rpc: _rpcUrlMap,\n                        clientMeta: walletConnectClientMeta,\n                        qrcode: true,\n                        ...connector.options,\n                      },\n                chains: _supporrtedChains,\n              });\n            }\n            if (\n              (typeof connector === \"string\" &&\n                (connector === \"coinbase\" || connector === \"walletLink\")) ||\n              (typeof connector === \"object\" &&\n                (connector.name === \"coinbase\" ||\n                  connector.name === \"walletLink\"))\n            ) {\n              const jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];\n              return new CoinbaseWalletConnector({\n                chains: _supporrtedChains,\n                options:\n                  typeof connector === \"string\"\n                    ? {\n                        ...walletLinkClientMeta,\n                        jsonRpcUrl,\n                      }\n                    : {\n                        ...walletLinkClientMeta,\n                        jsonRpcUrl,\n                        ...connector.options,\n                      },\n              });\n            }\n            if (typeof connector === \"object\" && connector.name === \"magic\") {\n              const jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];\n              return new MagicConnector({\n                chains: _supporrtedChains,\n                options: {\n                  ...connector.options,\n                  network: { rpcUrl: jsonRpcUrl, chainId: desiredChainId || 1 },\n                  rpcUrls: _rpcUrlMap,\n                },\n              });\n            }\n            if (\n              (typeof connector === \"string\" && connector === \"gnosis\") ||\n              (typeof connector === \"object\" && connector.name === \"gnosis\")\n            ) {\n              return new GnosisSafeConnector({\n                chains: _supporrtedChains,\n              });\n            }\n            return null;\n          })\n          .filter((c) => c !== null);\n      },\n    } as WagmiproviderProps;\n  }, [walletConnectors, _supporrtedChains, dAppMeta]);\n\n  const defaultSdkReadUrl =\n    _rpcUrlMap[(desiredChainId || -1) as keyof typeof _rpcUrlMap];\n\n  const sdkOptionsWithDefaults = useMemo(() => {\n    const opts: SDKOptions = sdkOptions;\n    return {\n      ...opts,\n      readonlySettings: {\n        ...(opts?.readonlySettings || {}),\n        rpcUrl: opts?.readonlySettings?.rpcUrl\n          ? opts.readonlySettings.rpcUrl\n          : defaultSdkReadUrl,\n      },\n    };\n  }, [sdkOptions, defaultSdkReadUrl]);\n\n  const queryClientWithDefault: QueryClient = useMemo(() => {\n    return queryClient ? queryClient : new QueryClient();\n  }, [queryClient]);\n\n  return (\n    <QueryClientProvider client={queryClientWithDefault}>\n      <WagmiProvider {...wagmiProps}>\n        <ThirdwebSDKProviderWagmiWrapper\n          desiredChainId={desiredChainId}\n          sdkOptions={sdkOptionsWithDefaults}\n          storageInterface={storageInterface}\n        >\n          {children}\n        </ThirdwebSDKProviderWagmiWrapper>\n      </WagmiProvider>\n    </QueryClientProvider>\n  );\n};\n\nexport interface ThirdwebSDKProviderProps\n  extends Pick<\n    ThirdwebProviderProps,\n    \"desiredChainId\" | \"sdkOptions\" | \"storageInterface\"\n  > {\n  signer?: Signer;\n  provider: ChainOrRpc | SignerOrProvider;\n}\n\nconst ThirdwebSDKProviderWagmiWrapper: React.FC<\n  React.PropsWithChildren<Omit<ThirdwebSDKProviderProps, \"signer\" | \"provider\">>\n> = ({ children, ...props }) => {\n  const provider = useProvider();\n  const signer = useSigner();\n  return (\n    <ThirdwebSDKProvider signer={signer} provider={provider} {...props}>\n      {children}\n    </ThirdwebSDKProvider>\n  );\n};\n\ninterface SDKContext {\n  sdk?: ThirdwebSDK;\n  _inProvider?: true;\n  desiredChainId: number;\n}\n\nconst ThirdwebSDKContext = createContext<SDKContext>({ desiredChainId: -1 });\n\n/**\n * A barebones wrapper around the Thirdweb SDK.\n *\n * You can use this in order to be able to pass a provider & signer directly to the SDK.\n *\n * @remarks Utilizing this provider will mean hooks for wallet management are not available, if you need those please use the {@link ThirdwebProvider} instead.\n *\n * @beta\n */\nexport const ThirdwebSDKProvider: React.FC<\n  React.PropsWithChildren<ThirdwebSDKProviderProps>\n> = ({\n  sdkOptions,\n  desiredChainId,\n  storageInterface,\n  provider,\n  signer,\n  children,\n}) => {\n  const sdk = useMemo(() => {\n    if (!desiredChainId || typeof window === \"undefined\") {\n      return undefined;\n    }\n    const _sdk = new ThirdwebSDK(provider, sdkOptions, storageInterface);\n    (_sdk as any)._chainId = desiredChainId;\n    return _sdk;\n  }, [provider, sdkOptions, storageInterface, desiredChainId]);\n\n  useEffect(() => {\n    if (signer && sdk && (sdk as any)._chainId === desiredChainId) {\n      sdk.updateSignerOrProvider(signer);\n    }\n  }, [signer, sdk, desiredChainId]);\n\n  const ctxValue = useMemo(\n    () => ({\n      sdk,\n      desiredChainId: desiredChainId || -1,\n      _inProvider: true as const,\n    }),\n    [sdk],\n  );\n\n  return (\n    <ThirdwebSDKContext.Provider value={ctxValue}>\n      {children}\n    </ThirdwebSDKContext.Provider>\n  );\n};\n\n/**\n *\n * @returns {@link ThirdwebSDK}\n * @internal\n */\nexport function useSDK(): ThirdwebSDK | undefined {\n  const ctx = React.useContext(ThirdwebSDKContext);\n  invariant(\n    ctx._inProvider,\n    \"useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?\",\n  );\n  return ctx.sdk;\n}\n\n/**\n *\n * @internal\n */\nexport function useDesiredChainId(): number {\n  const ctx = React.useContext(ThirdwebSDKContext);\n  invariant(\n    ctx._inProvider,\n    \"useDesiredChainId must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?\",\n  );\n  return ctx.desiredChainId;\n}\n\n/**\n *\n * @internal\n */\nexport function useActiveChainId(): SUPPORTED_CHAIN_ID | undefined {\n  const ctx = React.useContext(ThirdwebSDKContext);\n  invariant(\n    ctx._inProvider,\n    \"useActiveChainId must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?\",\n  );\n  return (ctx.sdk as any)?._chainId;\n}\n","import { useSDK } from \"../../Provider\";\nimport { ContractForContractType, ContractType } from \"@thirdweb-dev/sdk\";\n\n/**\n * @internal\n * @param contractType - the contract type\n * @param contractAddress - the contract address\n * @returns the instance of the contract for the given type and address\n */\nexport function useBuiltinContract<TContractType extends ContractType>(\n  contractType?: TContractType,\n  contractAddress?: string,\n): ContractForContractType<TContractType> | undefined {\n  const sdk = useSDK();\n  if (!sdk || !contractAddress || !contractType) {\n    return undefined;\n  }\n  return sdk.getBuiltInContract(contractAddress, contractType);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { EditionDrop } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of an `EditionDrop` contract. This conract is used to interface with ERC1155 compliant NFTs that can be lazily minted.\n * @param contractAddress - the address of the Edition Drop contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useEditionDrop } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const editionDrop = useEditionDrop(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the edition drop contract in the rest of the component\n *\n *   // For example, this function will let the connected wallet claim a new NFT\n *   async function claim(tokenId, quantity) {\n *     await editionDrop.claim(tokenId, quantity)\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useEditionDrop(\n  contractAddress?: string,\n): EditionDrop | undefined {\n  return useBuiltinContract(\"edition-drop\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Edition } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of an `Edition` contract. This contract is used to interface with ERC1155 compliant NFTs.\n * @param contractAddress - the address of the Edition contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useEdition } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const edition = useEdition(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the edition contract in the rest of the component\n *\n *   // For example, this function will return all the NFTs on this contract\n *   async function getNFTs() {\n *     const nfts = await edition.getAll()\n *     return nfts\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useEdition(contractAddress?: string): Edition | undefined {\n  return useBuiltinContract(\"edition\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { NFTDrop } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of an `NFTDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.\n * @param contractAddress - the address of the NFT Drop contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useNFTDrop } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const nftDrop = useNFTDrop(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the nft drop contract in the rest of the component\n *\n *   // For example, this function will let the connected wallet claim a new NFT\n *   async function claim(quantity) {\n *     await nftDrop.claim(quantity)\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useNFTDrop(contractAddress?: string): NFTDrop | undefined {\n  return useBuiltinContract(\"nft-drop\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Marketplace } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of a `Marketplace` contract. This contract is used to support marketplace for purchase and sale of on-chain assets.\n * @param contractAddress - the address of the Marketplace contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useMarketplace } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const marketplace = useMarketplace(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the marketplace contract in the rest of the component\n *\n *   // For example, this function will return all the listings on the marketplace\n *   async function getListings() {\n *     const listings = await marketplace.getAll()\n *     return listings\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useMarketplace(\n  contractAddress?: string,\n): Marketplace | undefined {\n  return useBuiltinContract(\"marketplace\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { NFTCollection } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of an `NFTCollection` contract. This contract is meant to interface with ERC721 compliant NFTs.\n * @param contractAddress - the address of the NFT Collection contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useNFTCollection } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const nftCollection = useNFTCollection(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the nftCollection contract in the rest of the component\n *\n *   // For example, this function will return all the NFTs on this contract\n *   async function getNFTs() {\n *     const nfts = await nftCollection.getAll()\n *     return nfts\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useNFTCollection(\n  contractAddress?: string,\n): NFTCollection | undefined {\n  return useBuiltinContract(\"nft-collection\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Pack } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of a `Pack` contract. This contract supports the creation of on-chain luck-based lootboxes.\n * @param contractAddress - the address of the Pack contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { usePack } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const pack = usePack(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the pack contract in the rest of the component\n *\n *   // For example, this function will get all the packs on this contract\n *   async function getPacks() {\n *     const packs = await pack.getAll()\n *     return packs\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function usePack(contractAddress?: string): Pack | undefined {\n  return useBuiltinContract(\"pack\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Token } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of an `Token` contract. This contract supports ERC20 compliant tokens.\n * @param contractAddress - the address of the Token contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useToken } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const token = useToken(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the token contract in the rest of the component\n *\n *   // For example, this function will get the connected wallets token balance\n *   async function balance() {\n *     const balance = await token.balance()\n *     return balance\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useToken(contractAddress?: string): Token | undefined {\n  return useBuiltinContract(\"token\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { TokenDrop } from \"@thirdweb-dev/sdk\";\n\n/**\n * Returns a Token contract instance\n * @param contractAddress - the address of the Token contract, found in your thirdweb dashboard\n * @internal\n */\nexport function useTokenDrop(contractAddress?: string): TokenDrop | undefined {\n  return useBuiltinContract(\"token-drop\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Vote } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of an `Vote` contract. This contract enables fully featured voting-based decentralized governance systems.\n * @param contractAddress - the address of the Vote contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useVote } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const vote = useVote(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the vote contract in the rest of the component\n *\n *   // For example, this function will get all the proposals on this contract\n *   async function getProposals() {\n *     const proposals = await vote.getAll()\n *     return proposals\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useVote(contractAddress?: string): Vote | undefined {\n  return useBuiltinContract(\"vote\", contractAddress);\n}\n","import { useBuiltinContract } from \"./useBuiltinContract\";\nimport { Split } from \"@thirdweb-dev/sdk\";\n\n/**\n * Hook for getting an instance of a `Split` contract. This contract supports fund distribution to multiple parties.\n * @param contractAddress - the address of the Split contract, found in your thirdweb dashboard\n *\n * @example\n * ```javascript\n * import { useSplit } from '@thirdweb-dev/react'\n *\n * export default function Component() {\n *   const split = useSplit(\"<YOUR-CONTRACT-ADDRESS>\")\n *\n *   // Now you can use the split contract in the rest of the component\n *\n *   // For example, this function will retrun all the receipients of the split\n *   async function getRecipients() {\n *     const recipients = await split.getAllRecipients()\n *     return recipients\n *   }\n *\n *   ...\n * }\n * ```\n * @public\n */\nexport function useSplit(contractAddress?: string): Split | undefined {\n  return useBuiltinContract(\"split\", contractAddress);\n}\n","import { useConnect as useWagmiConnect } from \"wagmi\";\n\n/**\n * for now just re-exported\n * @internal\n */\nexport function useConnect() {\n  return useWagmiConnect();\n}\n","import { GnosisSafeConnector } from \"../connectors/gnosis-safe\";\nimport { useConnect } from \"./useConnect\";\nimport { useAccount } from \"wagmi\";\n\n/**\n * Hook for disconnecting the currently connected wallet\n *\n * ```javascript\n * import { useDisconnect } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * The following will enable users to disconnect their wallet from the page.\n * ```javascript\n * import { useDisconnect } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const disconnect = useDisconnect()\n *\n *   return (\n *     <button onClick={disconnect}>\n *       Disconnect\n *     </button>\n *   )\n * }\n * ```\n *\n * Once users disconnect their wallet, the `useAddress`, `useChainId`, `useAccount`, and `useNetwork` hooks will no longer return values until a user connects their wallet again.\n *\n * @public\n */\nexport function useDisconnect(options?: { reconnectAfterGnosis?: boolean }) {\n  const optsWithDefaults = { ...{ reconnectAfterGnosis: true }, ...options };\n  const [, connect] = useConnect();\n  const [data, disconnect] = useAccount();\n\n  return async () => {\n    const previousConnector =\n      (data.data?.connector instanceof GnosisSafeConnector &&\n        data.data.connector.previousConnector) ||\n      undefined;\n    // if it's gnosis, just connect the previous connector\n    if (optsWithDefaults.reconnectAfterGnosis && previousConnector) {\n      try {\n        return await connect(previousConnector);\n      } catch (err) {\n        console.error(\"failed to re-connect to previous connector\", err);\n        // if it fails for whatever reason just disconnect\n        return disconnect();\n      }\n    }\n\n    return disconnect();\n  };\n}\n","import { useAccount } from \"wagmi\";\n\n/**\n * Hook for accessing the address of the connected wallet\n *\n * ```javascript\n * import { useAddress } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * To get the address of the connected wallet, you can use the hook as follows:\n *\n * ```javascript\n * import { useAddress } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const address = useAddress()\n *\n *   return <div>{address}</div>\n * }\n * ```\n *\n * The `address` variable will hold the address of the connected wallet if a user has connected using one of the supported wallet connection hooks.\n *\n * @public\n */\nexport function useAddress(): string | undefined {\n  const [account] = useAccount();\n  return account.data?.address;\n}\n","import { IStorage, SDKOptions, ThirdwebSDK } from \"@thirdweb-dev/sdk\";\nimport { useMemo } from \"react\";\n\n/**\n * @internal\n */\nexport function useReadonlySDK(\n  readonlyRpcUrl: string,\n  sdkOptions: SDKOptions,\n  storageInterface?: IStorage,\n): ThirdwebSDK {\n  return useMemo(() => {\n    return new ThirdwebSDK(\n      readonlyRpcUrl,\n      {\n        ...sdkOptions,\n        readonlySettings: {\n          ...sdkOptions?.readonlySettings,\n          rpcUrl: readonlyRpcUrl,\n        },\n      },\n      storageInterface,\n    );\n  }, [readonlyRpcUrl, sdkOptions]);\n}\n","import {\n  BotInfo,\n  BrowserInfo,\n  NodeInfo,\n  ReactNativeInfo,\n  SearchBotDeviceInfo,\n  detect,\n} from \"detect-browser\";\n\nfunction detectEnv(\n  userAgent?: string,\n):\n  | BrowserInfo\n  | BotInfo\n  | NodeInfo\n  | SearchBotDeviceInfo\n  | ReactNativeInfo\n  | null {\n  return detect(userAgent);\n}\n\n/**\n * @internal\n */\nexport function isAndroid(): boolean {\n  const os = detectOS();\n  return os ? os.toLowerCase().includes(\"android\") : false;\n}\n\n/**\n * @internal\n */\nexport function isIOS(): boolean {\n  const os = detectOS();\n  return os\n    ? os.toLowerCase().includes(\"ios\") ||\n        (os.toLowerCase().includes(\"mac\") && navigator.maxTouchPoints > 1)\n    : false;\n}\n\n/**\n * @internal\n */\nfunction detectOS() {\n  const env = detectEnv();\n  return env?.os ? env.os : undefined;\n}\n\n/**\n * @internal\n */\nexport function isMobile(): boolean {\n  const os = detectOS();\n  return os ? isAndroid() || isIOS() : false;\n}\n","import { isAndroid, isMobile } from \"../../utils/isMobile\";\nimport { useConnect } from \"../useConnect\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a Metamask wallet.\n *\n * ```javascript\n * import { useMetamask } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * We can allow users to connect their metamask wallets as follows:\n * ```javascript\n * import { useMetamask } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithMetamask = useMetamask()\n *\n *   return (\n *     <button onClick={connectWithMetamask}>\n *       Connect Metamask\n *     </button>\n *   )\n * }\n * ```\n * Here, we use the `useMetamask` hook to handle metamask connection.\n * When a user clicks the button, we'll call the `connectWithMetamask` function, which will prompt users to connect their metamask wallet.\n *\n * @public\n */\nexport function useMetamask() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Metamask connector not ready to be used, yet\");\n  }\n\n  const isMetaMaskInjected =\n    typeof window !== \"undefined\" && window.ethereum?.isMetaMask;\n\n  const shouldUseWalletConnect = isMobile() && !isMetaMaskInjected;\n\n  // injected connector\n  const injectedConnector = connectors.data.connectors.find(\n    (c) => c.id === \"injected\",\n  );\n  // walletConnect connector\n  const walletConnectConnector = connectors.data.connectors.find(\n    (c) => c.id === \"walletConnect\",\n  );\n\n  const connector =\n    (shouldUseWalletConnect ? walletConnectConnector : injectedConnector) ||\n    injectedConnector;\n\n  invariant(\n    connector,\n    \"No connector found, please make sure you provide the InjectedConnector to your <ThirdwebProvider />\",\n  );\n\n  return async () => {\n    // if we don't have an injected provider\n    if (!isMetaMaskInjected) {\n      // this is the fallback uri that should work no matter what\n      let uri = `https://metamask.app.link/dapp/${\n        window.location.host + window.location.pathname + window.location.search\n      }`;\n\n      // if we have walletconnect etc, we can try to use that\n      if (shouldUseWalletConnect && connector.id === \"walletConnect\") {\n        try {\n          uri = (await connector.getProvider()).connector.uri;\n          // if android we can use the uri straight\n          uri = isAndroid()\n            ? uri\n            : // otherwise we have to use /dapp link for now\n              `https://metamask.app.link/dapp/${\n                window.location.host +\n                window.location.pathname +\n                window.location.search\n              }`;\n        } catch (err) {\n          console.warn(\"failed to get provider.connector.uri\", err);\n        }\n      }\n      // open whatever uri we end up with in a new tab\n      window.open(uri, \"_blank\");\n\n      return Promise.resolve({\n        error: new Error(\"metamask not injected\"),\n      });\n    }\n\n    // otherwise we have MM avaiable, so we can just use it\n    return await connect(connector);\n  };\n}\n","import { useConnect } from \"../useConnect\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a mobile wallet with Wallet Connect\n *\n * ```javascript\n * import { useWalletConnect } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * We can allows user to connect their mobile wallets as follows:\n * ```javascript\n * import { useWalletConnect } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithWalletConnect = useWalletConnect()\n *\n *   return (\n *     <button onClick={connectWithWalletConnect}>\n *       Connect WalletConnect\n *     </button>\n *   )\n * }\n * ```\n *\n * When users click this button, a popup will appear on the screen prompting them to scan a QR code from their phone to connect their mobile wallets.\n * Once they scan the QR code from a wallet connect supported mobile wallet, their wallet will then be connected to the page as expected.\n *\n * @public\n */\nexport function useWalletConnect() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () =>\n      Promise.reject(\"WalletConnect connector not ready to be used, yet\");\n  }\n  const connector = connectors.data.connectors.find(\n    (c) => c.id === \"walletConnect\",\n  );\n  invariant(\n    connector,\n    \"WalletConnect connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return () => connect(connector);\n}\n","import { useConnect } from \"../useConnect\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a Coinbase wallet.\n *\n * ```javascript\n * import { useCoinbaseWallet } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * We can allow users to connect with Coinbase Wallet as follows:\n * ```javascript\n * import { useCoinbaseWallet } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithCoinbaseWallet = useCoinbaseWallet()\n *\n *   return (\n *     <button onClick={connectWithCoinbaseWallet}>\n *       Connect Coinbase Wallet\n *     </button>\n *   )\n * }\n * ```\n *\n * Upon clicking this button, users will be prompted with a popup asking them scan a QR code with their Coinbase Wallet.\n * Once they scan the QR code, their wallet will then be connected to the page as expected.\n *\n * @public\n */\nexport function useCoinbaseWallet() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Coinbase connector not ready to be used, yet\");\n  }\n  const connector = connectors.data.connectors.find(\n    (c) => c.id === \"coinbasewallet\",\n  );\n  invariant(\n    connector,\n    \"Coinbase connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return () => connect(connector);\n}\n\n/**\n * Convienience hook for connecting to a wallet via WalletLink (coinbase wallet)\n * @returns a function that will prompt the user to connect their wallet via WalletLink (coinbase wallet)\n * @internal\n */\nexport function useWalletLink() {\n  return useCoinbaseWallet();\n}\n","import {\n  GnosisConnectorArguments,\n  GnosisSafeConnector,\n} from \"../../connectors/gnosis-safe\";\nimport { useConnect } from \"../useConnect\";\nimport { utils } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to a Gnosis Safe. This enables multisig wallets to connect to your application and sing transactions.\n *\n * ```javascript\n * import { useGnosis } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * ```javascript\n * import { useGnosis } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const connectWithGnosis = useGnosis()\n *\n *   return (\n *     <button onClick={() => connectWithGnosis({ safeAddress: \"0x...\", safeChainId: 1 })}>\n *       Connect Gnosis Safe\n *     </button>\n *   )\n * }\n * ```\n *\n * @public\n */\nexport function useGnosis() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Gnosis connector not ready to be used, yet\");\n  }\n  const connector = connectors.data.connectors.find((c) => c.id === \"gnosis\");\n  invariant(\n    connector,\n    \"Gnosis connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return async (config: GnosisConnectorArguments) => {\n    const previousConnector = connectors.data.connector;\n    const previousConnectorChain = await previousConnector?.getChainId();\n    invariant(\n      !!previousConnector,\n      \"Cannot connect to Gnosis Safe without first being connected to a personal wallet.\",\n    );\n    invariant(\n      previousConnectorChain === config.safeChainId,\n      \"Gnosis safe chain id must match personal wallet chain id.\",\n    );\n    invariant(\n      utils.isAddress(config.safeAddress),\n      \"Gnosis safe address must be a valid address.\",\n    );\n    (connector as GnosisSafeConnector).setConfiguration(\n      previousConnector,\n      config,\n    );\n    return connect(connector);\n  };\n}\n","import { MagicConnector } from \"../../connectors/magic\";\nimport { useConnect } from \"../useConnect\";\nimport { LoginWithMagicLinkConfiguration } from \"magic-sdk\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Hook for connecting to an email wallet using magic link.\n * This enables users without their own wallets to connect to your application and sign transactions securely using their email.\n *\n * ```javascript\n * import { useMagic } from \"@thirdweb-dev/react\"\n * ```\n *\n *\n * @example\n * Before using this hook, you first need to set up the magic configuration in your `ThirdwebProvider`, including your magic API key.\n *\n * ```javascript\n * // Add the magic configuration object to your wallet connectors\n * const connectors = [\n *   \"metamask\",\n *   \"walletConnect\",\n *   \"walletLink\",\n *   {\n *     name: \"magic\",\n *     options: {\n *       apiKey: \"your-magic-api-key\",\n *     }\n *   }\n * ]\n *\n * // Add the above to the walletConnectors prop of your <ThirdwebProvider />\n * const Provider = ({ children }) => (\n *   return (\n *     <ThirdwebProvider\n *       walletConnectors={connectors}\n *       // Specify remaining parameters\n *       ...\n *     >\n *       {children}\n *     </ThirdwebProvider>\n *   )\n * }\n * ```\n *\n * In order to use the hook to connect users with magic link, you just need to provide the users email to the connect function.\n *\n * You can setup the hook with the following configuration:\n * ```javascript\n * import { useMagic } from \"@thirdweb-dev/react\"\n * import { useState } from \"react\"\n *\n * const LoginWithMagicLink = () => {\n *   const connectWithMagic = useMagic()\n *   const [email, setEmail] = useState()\n *\n *   return (\n *     <div>\n *       <input value={email} onChange={(e) => setEmail(e.target.value)} />\n *       <button onClick={() => connectWithMagic({ email })}>Login</button>\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nexport function useMagic() {\n  const [connectors, connect] = useConnect();\n  if (connectors.loading) {\n    return () => Promise.reject(\"Magic connector not ready to be used, yet\");\n  }\n\n  const connector = connectors.data.connectors.find((c) => c.id === \"magic\");\n\n  invariant(\n    connector,\n    \"Magic connector not found, please make sure it is provided to your <ThirdwebProvider />\",\n  );\n\n  return (configuration: LoginWithMagicLinkConfiguration) => {\n    (connector as MagicConnector).setConfiguration(configuration);\n    return connect(connector);\n  };\n}\n","import { useNetwork } from \"wagmi\";\n\n/**\n * Hook for accessing the chain ID of the network the current wallet is connected to\n *\n * ```javascript\n * import { useChainId } from \"@thirdweb-dev/react\"\n * ```\n *\n * @example\n * You can get the chain ID of the connected wallet by using the hook as follows:\n * ```javascript\n * import { useChainId } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const chainId = useChainId()\n *\n *   return <div>{chainId}</div>\n * }\n * ```\n * @public\n */\nexport function useChainId(): number | undefined {\n  return useNetwork()[\"0\"].data.chain?.id;\n}\n","import { useDesiredChainId } from \"../Provider\";\nimport { useChainId } from \"./useChainId\";\n\n/**\n * Hook for checking whether the connected wallet is on the correct network specified by the `desiredChainId` passed to the `<ThirdwebProvider />`.\n *\n * ```javascript\n * import { useNetworkMistmatch } from \"@thirdweb-dev/react\"\n * ```\n *\n * @returns `true` if the chainId of the connected wallet is different from the desired chainId passed into <ThirdwebProvider />\n *\n * @example\n * You can check if a users wallet is connected to the correct chain ID as follows:\n * ```javascript\n * import { useNetworkMismatch } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const isMismatched = useNetworkMismatch()\n *\n *   return <div>{isMismatched}</div>\n * }\n * ```\n *\n * From here, you can prompt users to switch their network using the `useNetwork` hook.\n *\n * @public\n */\nexport function useNetworkMismatch() {\n  const desiredChainId = useDesiredChainId();\n  const activeChainId = useChainId();\n\n  if (desiredChainId === -1) {\n    // means no desiredChainId is set in the <ThirdwebProvider />, so we don't care about the network mismatch\n    return false;\n  }\n  if (!activeChainId) {\n    // means no wallet is connected yet, so we don't care about the network mismatch\n    return false;\n  }\n  // check if the chainIds are different\n  return desiredChainId !== activeChainId;\n}\n","import { useNetwork as useWagmiNetwork } from \"wagmi\";\n\n/**\n * Hook for getting metadata about the network the current wallet is connected to and switching networks\n *\n * ```javascript\n * import { useNetwork } from \"@thirdweb-dev/react\"\n * ```\n *\n * @example\n * You can use this hook as follows:\n * ```javascript\n * import { useChainId } from \"@thirdweb-dev/react\"\n *\n * const App = () => {\n *   const {\n *     activeChain,\n *     chains,\n *     error,\n *     isLoading,\n *     pendingChainId,\n *     switchNetwork,\n *   } = useNetwork()\n *\n *   return (\n *     <>\n *       {activeChain && <div>Connected to {activeChain.name}</div>}\n *\n *       {chains.map((x) => (\n *         <button\n *           disabled={!switchNetwork || x.id === activeChain?.id}\n *           key={x.id}\n *           onClick={() => network.switchNetwork?.(x.id)}\n *         >\n *           {x.name}\n *           {isLoading && pendingChainId === x.id && ' (switching)'}\n *         </button>\n *       ))}\n *\n *       <div>{error && error.message}</div>\n *     </>\n *   )\n * }\n * ```\n *\n * This will let users switch their network to any of the available chains on clicking one of the buttons.\n *\n * It's important to note that some wallet apps do not support programmatic network switching and switchNetwork will be undefined.\n * For those situations, you can typically switch networks in the wallet app this hook will still work.\n *\n * @public\n */\n\nexport function useNetwork() {\n  return useWagmiNetwork();\n}\n","// contract hooks\nexport * from \"./Provider\";\nexport * from \"./hooks/contracts\";\nexport * from \"./hooks/useDisconnect\";\nexport * from \"./hooks/useConnect\";\nexport * from \"./hooks/useSigner\";\nexport * from \"./hooks/useAddress\";\nexport * from \"./hooks/useReadonlySDK\";\nexport * from \"./hooks/connectors/useMetamask\";\nexport * from \"./hooks/connectors/useWalletConnect\";\nexport * from \"./hooks/connectors/useWalletLink\";\nexport * from \"./hooks/connectors/useGnosis\";\nexport * from \"./hooks/connectors/useMagic\";\nexport * from \"./hooks/useChainId\";\nexport * from \"./hooks/useNetworkMismatch\";\nexport * from \"./hooks/useNetwork\";\n\n// re-exports\nexport { defaultChains, defaultL2Chains, useAccount } from \"wagmi\";\nexport { ChainId, IpfsStorage } from \"@thirdweb-dev/sdk\";\n// ui components\nexport * from \"./components/MediaRenderer\";\nexport * from \"./components/NftMedia\";\n\n// async hooks\nexport * from \"./hooks/async/contracts\";\nexport * from \"./hooks/async/nft\";\nexport * from \"./hooks/async/drop\";\nexport * from \"./hooks/async/marketplace\";\nexport * from \"./hooks/async/token\";\nexport * from \"./hooks/async/claim-conditions\";\nexport * from \"./hooks/async/wallet\";\n\n// types\nexport * from \"./types\";\n","export const DEFAULT_IPFS_GATEWAY = \"https://gateway.ipfscdn.io/ipfs/\";\n\nexport interface IPFSResolverOptions {\n  gatewayUrl: string;\n}\n\nexport const DEFAULT_IPFS_RESOLVER_OPTIONS: IPFSResolverOptions = {\n  gatewayUrl: DEFAULT_IPFS_GATEWAY,\n};\n","import { DEFAULT_IPFS_RESOLVER_OPTIONS } from \"../constants/ipfs\";\nimport mime from \"mime/lite\";\n\nexport function resolveIpfsUri(\n  uri?: string,\n  options = DEFAULT_IPFS_RESOLVER_OPTIONS,\n) {\n  if (!uri) {\n    return undefined;\n  }\n  if (uri.startsWith(\"ipfs://\")) {\n    return uri.replace(\"ipfs://\", options.gatewayUrl);\n  }\n  return uri;\n}\n\nexport async function resolveMimeType(url?: string) {\n  if (!url) {\n    return undefined;\n  }\n  const mimeType = mime.getType(url);\n  if (mimeType) {\n    return mimeType;\n  }\n\n  const res = await fetch(url, {\n    method: \"HEAD\",\n  });\n  if (res.ok && res.headers.has(\"content-type\")) {\n    return res.headers.get(\"content-type\") ?? undefined;\n  }\n  // we failed to resolve the mime type, return null\n  return undefined;\n}\n","let video: HTMLVideoElement;\n\nfunction supportsVideoType(mimeType?: string) {\n  if (\n    typeof window === \"undefined\" ||\n    !mimeType ||\n    !mimeType.startsWith(\"video/\")\n  ) {\n    return \"\";\n  }\n\n  if (!video) {\n    video = document.createElement(\"video\");\n  }\n\n  return video.canPlayType(mimeType);\n}\n\nexport function shouldRenderVideoTag(mimeType?: string) {\n  return !!supportsVideoType(mimeType);\n}\n\nlet audio: HTMLAudioElement;\n\nfunction supportsAudioType(mimeType?: string) {\n  if (\n    typeof window === \"undefined\" ||\n    !mimeType ||\n    !mimeType.startsWith(\"audio/\")\n  ) {\n    return \"\";\n  }\n\n  if (!audio) {\n    audio = document.createElement(\"audio\");\n  }\n\n  return audio.canPlayType(mimeType);\n}\n\nexport function shouldRenderAudioTag(mimeType?: string) {\n  return !!supportsAudioType(mimeType);\n}\n","export function mergeRefs<T = any>(\n  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T>>,\n): React.RefCallback<T> {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n        // eslint-disable-next-line eqeqeq\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n}\n","import React, { SVGProps } from \"react\";\n\nexport const CarbonDocumentUnknown: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <circle cx=\"9\" cy=\"28.5\" r=\"1.5\" fill=\"currentColor\"></circle>\n      <path\n        fill=\"currentColor\"\n        d=\"M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z\"\n      ></path>\n      <path\n        fill=\"currentColor\"\n        d=\"m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z\"\n      ></path>\n    </svg>\n  );\n};\n\nexport const CarbonDocumentAudio: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z\"\n      ></path>\n      <path\n        fill=\"currentColor\"\n        d=\"M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z\"\n      ></path>\n    </svg>\n  );\n};\n\nexport const CarbonPauseFilled: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z\"\n      ></path>\n    </svg>\n  );\n};\n\nexport const CarbonPlayFilledAlt: React.VFC<SVGProps<SVGSVGElement>> = (\n  props,\n) => {\n  return (\n    <svg width=\"1em\" height=\"1em\" viewBox=\"0 0 32 32\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z\"\n      ></path>\n    </svg>\n  );\n};\n","import { resolveIpfsUri, resolveMimeType } from \"../utils/ipfs\";\nimport { shouldRenderAudioTag, shouldRenderVideoTag } from \"../utils/media\";\nimport { mergeRefs } from \"../utils/react\";\nimport {\n  CarbonDocumentAudio,\n  CarbonDocumentUnknown,\n  CarbonPauseFilled,\n  CarbonPlayFilledAlt,\n} from \"./Icons\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport useDimensions from \"react-cool-dimensions\";\nimport { useQuery } from \"react-query\";\n\nexport interface SharedMediaProps {\n  className?: string;\n  style?: React.CSSProperties;\n  width?: HTMLIFrameElement[\"width\"];\n  height?: HTMLIFrameElement[\"height\"];\n  /**\n   * Require user interaction to play the media. (default false)\n   */\n  requireInteraction?: boolean;\n  /**\n   * Show the media controls (where applicable) (default false)\n   */\n  controls?: HTMLVideoElement[\"controls\"];\n}\n\n/**\n *\n * The props for the {@link MediaRenderer} component.\n * @public\n */\nexport interface MediaRendererProps extends SharedMediaProps {\n  /**\n   * The media source uri.\n   */\n  src?: string | null;\n  /**\n   * The alt text for the media.\n   */\n  alt?: string;\n  /**\n   * The media poster image uri. (if applicable)\n   */\n  poster?: string | null;\n}\n\ninterface PlayButtonProps {\n  onClick: () => void;\n  isPlaying: boolean;\n}\n\nconst PlayButton: React.VFC<PlayButtonProps> = ({ onClick, isPlaying }) => {\n  const [isHovering, setIsHovering] = useState(false);\n  const onMouseEnter = () => setIsHovering(true);\n  const onMouseLeave = () => setIsHovering(false);\n  const onMouseDown = () => setIsHovering(false);\n  const onMouseUp = () => setIsHovering(true);\n  return (\n    <button\n      style={{\n        position: \"absolute\",\n        bottom: 0,\n        right: 0,\n        transform: \"translate(-25%, -25%)\",\n        maxWidth: \"32px\",\n        width: \"8%\",\n        minWidth: \"24px\",\n        aspectRatio: \"1\",\n        zIndex: 3,\n        backgroundColor: \"#fff\",\n        color: \"rgb(138, 147, 155)\",\n        display: \"grid\",\n        placeItems: \"center\",\n        borderRadius: \"50%\",\n        border: \"1px solid rgb(229, 232, 235)\",\n        cursor: \"pointer\",\n        ...(isHovering\n          ? {\n              color: \"rgb(53, 56, 64)\",\n              boxShadow: \"rgb(4 17 29 / 25%) 0px 0px 8px 0px\",\n            }\n          : {}),\n      }}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      onMouseDown={onMouseDown}\n      onMouseUp={onMouseUp}\n    >\n      {!isPlaying ? (\n        <CarbonPlayFilledAlt style={{ width: \"66%\", height: \"66%\" }} />\n      ) : (\n        <CarbonPauseFilled style={{ width: \"66%\", height: \"66%\" }} />\n      )}\n    </button>\n  );\n};\n\nconst VideoPlayer = React.forwardRef<\n  HTMLVideoElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      width,\n      height,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const videoRef = useRef<HTMLVideoElement>(null);\n    const [playing, setPlaying] = useState(!requireInteraction);\n    const [muted, setMuted] = useState(true);\n\n    useEffect(() => {\n      if (videoRef.current) {\n        if (playing) {\n          videoRef.current.play();\n        } else {\n          videoRef.current.pause();\n          videoRef.current.currentTime = 0;\n        }\n      }\n    }, [playing]);\n\n    return (\n      <div style={{ position: \"relative\", ...style }} {...restProps}>\n        <video\n          ref={mergeRefs([videoRef, ref])}\n          src={src ?? undefined}\n          poster={poster ?? undefined}\n          loop\n          playsInline\n          muted={muted}\n          preload={poster ? \"metadata\" : \"auto\"}\n          onCanPlay={() => {\n            if (playing) {\n              videoRef.current?.play();\n            }\n          }}\n          width={width}\n          height={height}\n          controls={controls}\n          style={{\n            height: \"100%\",\n            width: \"100%\",\n            objectFit: \"contain\",\n            zIndex: 1,\n            transition: \"opacity .5s\",\n            opacity: !poster ? 1 : playing ? 1 : 0,\n          }}\n        />\n        {poster && (\n          <img\n            src={poster}\n            style={{\n              objectFit: \"contain\",\n              pointerEvents: \"none\",\n              position: \"absolute\",\n              width: \"100%\",\n              height: \"100%\",\n              zIndex: 2,\n              transition: \"opacity .5s\",\n              opacity: playing ? 0 : 1,\n              top: 0,\n              left: 0,\n              right: 0,\n              bottom: 0,\n            }}\n          />\n        )}\n        <PlayButton\n          onClick={() => {\n            setPlaying((prev) => !prev);\n            setMuted(false);\n          }}\n          isPlaying={playing}\n        />\n      </div>\n    );\n  },\n);\n\nconst AudioPlayer = React.forwardRef<\n  HTMLAudioElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      height,\n      width,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const audioRef = useRef<HTMLAudioElement>(null);\n    const [playing, setPlaying] = useState(false);\n    const [muted, setMuted] = useState(true);\n\n    useEffect(() => {\n      if (audioRef.current) {\n        if (playing) {\n          audioRef.current.play();\n        } else {\n          audioRef.current.pause();\n          audioRef.current.currentTime = 0;\n        }\n      }\n    }, [playing]);\n\n    return (\n      <div style={{ position: \"relative\", ...style }} {...restProps}>\n        {poster ? (\n          <img\n            height={height}\n            width={width}\n            src={poster}\n            style={{\n              height: \"100%\",\n              width: \"100%\",\n              pointerEvents: \"none\",\n              objectFit: \"contain\",\n            }}\n          />\n        ) : (\n          <div\n            style={{\n              width: \"100%\",\n              height: \"100%\",\n              display: \"grid\",\n              placeItems: \"center\",\n              pointerEvents: \"none\",\n              backgroundColor: \"#fff\",\n              color: \"rgb(138, 147, 155)\",\n            }}\n          >\n            <CarbonDocumentAudio style={{ height: \"64px\", width: \"64px\" }} />\n          </div>\n        )}\n\n        <PlayButton\n          onClick={() => {\n            setPlaying((prev) => !prev);\n            setMuted(false);\n          }}\n          isPlaying={playing}\n        />\n        <audio\n          ref={mergeRefs([audioRef, ref])}\n          src={src ?? undefined}\n          loop\n          playsInline\n          muted={muted}\n          style={{\n            position: \"absolute\",\n            opacity: 0,\n            pointerEvents: \"none\",\n            zIndex: -1,\n            visibility: \"hidden\",\n          }}\n        />\n      </div>\n    );\n  },\n);\n\nconst IframePlayer = React.forwardRef<\n  HTMLIFrameElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      height,\n      width,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const { observe, width: elWidth } = useDimensions<HTMLDivElement | null>();\n    const [playing, setPlaying] = useState(!requireInteraction);\n\n    if (elWidth < 300) {\n      return (\n        <div ref={observe}>\n          <LinkPlayer style={style} src={src} alt={alt} {...restProps} />\n        </div>\n      );\n    }\n\n    return (\n      <div\n        style={{ position: \"relative\", ...style }}\n        {...restProps}\n        ref={observe}\n      >\n        <iframe\n          src={playing ? src ?? undefined : undefined}\n          ref={ref}\n          style={{\n            objectFit: \"contain\",\n            zIndex: 1,\n            height: \"100%\",\n            width: \"100%\",\n            transition: \"opacity .5s\",\n            opacity: !poster ? 1 : playing ? 1 : 0,\n          }}\n        />\n        {poster && (\n          <img\n            src={poster}\n            style={{\n              objectFit: \"contain\",\n              pointerEvents: \"none\",\n              position: \"absolute\",\n              width: \"100%\",\n              height: \"100%\",\n              zIndex: 2,\n              transition: \"opacity .5s\",\n              opacity: playing ? 0 : 1,\n              top: 0,\n              left: 0,\n              right: 0,\n              bottom: 0,\n            }}\n          />\n        )}\n        <PlayButton\n          onClick={() => {\n            setPlaying((prev) => !prev);\n          }}\n          isPlaying={playing}\n        />\n      </div>\n    );\n  },\n);\nconst LinkPlayer = React.forwardRef<\n  HTMLAnchorElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      src,\n      alt,\n      poster,\n      requireInteraction,\n      children,\n      style,\n      height,\n      width,\n      controls,\n      ...restProps\n    },\n    ref,\n  ) => {\n    return (\n      <div style={{ position: \"relative\", ...style }} {...restProps}>\n        <div\n          style={{\n            width: \"100%\",\n            height: \"100%\",\n            display: \"grid\",\n            placeItems: \"center\",\n            backgroundColor: \"#fff\",\n            color: \"rgb(138, 147, 155)\",\n          }}\n        >\n          <div\n            style={{\n              display: \"flex\",\n              flexDirection: \"column\",\n              gap: \"8px\",\n              alignItems: \"center\",\n              flexWrap: \"nowrap\",\n            }}\n          >\n            <CarbonDocumentUnknown\n              style={{\n                maxWidth: \"128px\",\n                minWidth: \"48px\",\n                width: \"50%\",\n                aspectRatio: \"1\",\n              }}\n            />\n            <a\n              rel=\"noopener noreferrer\"\n              style={{\n                textDecoration: \"underline\",\n                color: \"rgb(138, 147, 155)\",\n              }}\n              href={src ?? undefined}\n              target=\"_blank\"\n              ref={ref as unknown as React.LegacyRef<HTMLAnchorElement>}\n            >\n              {alt || \"File\"}\n            </a>\n          </div>\n        </div>\n      </div>\n    );\n  },\n);\n\n/**\n * This component can be used to render any media type, including image, audio, video, and html files.\n * Its convenient for rendering NFT media files, as these can be a variety of different types.\n * The component falls back to a external link if the media type is not supported.\n *\n * Props: {@link MediaRendererProps}\n *\n * @example\n * We can take a video file hosted on IPFS and render it using this component as follows\n * ```jsx\n * const Component = () => {\n *   return <MediaRenderer\n *     src=\"ipfs://Qmb9ZV5yznE4C4YvyJe8DVFv1LSVkebdekY6HjLVaKmHZi\"\n *     alt=\"A mp4 video\"\n *   />\n * }\n * ```\n *\n * You can try switching out the `src` prop to different types of URLs and media types to explore the possibilities.\n */\nexport const MediaRenderer = React.forwardRef<\n  HTMLMediaElement,\n  React.PropsWithChildren<MediaRendererProps>\n>(\n  (\n    {\n      children,\n      src,\n      poster,\n      alt,\n      requireInteraction = false,\n      style,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const mergedStyle: React.CSSProperties = { objectFit: \"contain\", ...style };\n    const videoOrImageSrc = useResolvedMediaType(src ?? undefined);\n    const possiblePosterSrc = useResolvedMediaType(poster ?? undefined);\n    if (!videoOrImageSrc.mimeType) {\n      return (\n        <img\n          style={mergedStyle}\n          {...restProps}\n          ref={ref as unknown as React.LegacyRef<HTMLImageElement>}\n        />\n      );\n    } else if (videoOrImageSrc.mimeType === \"text/html\") {\n      return (\n        <IframePlayer\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          poster={possiblePosterSrc.url}\n          requireInteraction={requireInteraction}\n          {...restProps}\n        />\n      );\n    } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {\n      return (\n        <VideoPlayer\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          poster={possiblePosterSrc.url}\n          requireInteraction={requireInteraction}\n          {...restProps}\n        />\n      );\n    } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {\n      return (\n        <AudioPlayer\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          poster={possiblePosterSrc.url}\n          requireInteraction={requireInteraction}\n          {...restProps}\n        />\n      );\n    } else if (videoOrImageSrc.mimeType.startsWith(\"image/\")) {\n      return (\n        <img\n          style={mergedStyle}\n          src={videoOrImageSrc.url}\n          alt={alt}\n          ref={ref as unknown as React.LegacyRef<HTMLImageElement>}\n          {...restProps}\n        />\n      );\n    }\n    return (\n      <LinkPlayer\n        style={mergedStyle}\n        src={videoOrImageSrc.url}\n        alt={alt}\n        ref={ref as unknown as React.Ref<HTMLAnchorElement>}\n        {...restProps}\n      />\n    );\n  },\n);\n\nexport interface MediaType {\n  url?: string;\n  mimeType?: string;\n}\n\n/**\n * @param uri - the uri to resolve (can be a url or a ipfs://\\<cid\\>)\n * @returns the fully resolved url + mime type of the media\n *\n * @example\n * Usage with fully formed url:\n * ```jsx\n * const Component = () => {\n *   const resolved = useResolvedMediaType(\"https://example.com/video.mp4\");\n *   console.log(\"mime type\", resolved.data.mimeType);\n *   console.log(\"url\", resolved.data.url);\n *   return null;\n * }\n * ```\n *\n * Usage with ipfs cid:\n * ```jsx\n * const Component = () => {\n *   const resolved = useResolvedMediaType(\"ipfs://QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvsd\");\n *   console.log(\"mime type\", resolved.data.mimeType);\n *   console.log(\"url\", resolved.data.url);\n *   return null;\n * }\n * ```\n */\nexport function useResolvedMediaType(uri?: string) {\n  const resolvedUrl = useMemo(() => resolveIpfsUri(uri), [uri]);\n  const resolvedMimType = useQuery(\n    [\"mime-type\", resolvedUrl],\n    () => resolveMimeType(resolvedUrl),\n    {\n      enabled: !!resolvedUrl,\n    },\n  );\n\n  return {\n    url: resolvedUrl,\n    mimeType: resolvedMimType.data,\n  };\n}\n","import { MediaRenderer, SharedMediaProps } from \"./MediaRenderer\";\nimport { NFTMetadata } from \"@thirdweb-dev/sdk\";\nimport React from \"react\";\n\n/**\n * The props for the {@link ThirdwebNftMedia} component.\n */\nexport interface ThirdwebNftMediaProps extends SharedMediaProps {\n  /**\n   * The NFT metadata of the NFT returned by the thirdweb sdk.\n   */\n  metadata: NFTMetadata;\n}\n\n/**\n * Render a nft based on the common metadata returned by the thirdweb sdk.\n */\nexport const ThirdwebNftMedia = React.forwardRef<\n  HTMLMediaElement,\n  ThirdwebNftMediaProps\n>(({ metadata, ...props }, ref) => {\n  return (\n    <MediaRenderer\n      src={metadata.animation_url || metadata.image}\n      poster={metadata.image}\n      alt={metadata.name}\n      ref={ref}\n      {...props}\n    />\n  );\n});\n","import { ContractAddress, RequiredParam, WalletAddress } from \"../types\";\nimport type {\n  MarketplaceFilter,\n  QueryAllParams,\n  SUPPORTED_CHAIN_ID,\n} from \"@thirdweb-dev/sdk\";\nimport { BigNumberish, constants } from \"ethers\";\nimport { QueryClient, QueryKey } from \"react-query\";\n\nconst TW_CACHE_KEY_PREFIX = \"tw-cache\";\n\nfunction createCachekey(input: QueryKey): QueryKey {\n  if (input[0] === TW_CACHE_KEY_PREFIX) {\n    return input;\n  }\n  return [TW_CACHE_KEY_PREFIX, ...input];\n}\n\n/**\n * @internal\n */\nexport function createContractCacheKey(\n  contractAddress: string = constants.AddressZero,\n  input: QueryKey = [],\n): QueryKey {\n  return createCachekey([\"contract\", contractAddress, ...input]);\n}\n\n/**\n @internal\n */\nexport function createCacheKeyWithNetwork(\n  input: QueryKey,\n  chainId: RequiredParam<SUPPORTED_CHAIN_ID>,\n): QueryKey {\n  return cacheKeys.network.active(chainId).concat(input);\n}\n\n/**\n * @internal\n */\nexport function invalidateContractAndBalances(\n  queryClient: QueryClient,\n  contractAddress: RequiredParam<ContractAddress>,\n  chainId: RequiredParam<SUPPORTED_CHAIN_ID>,\n): Promise<unknown> {\n  return Promise.all([\n    queryClient.invalidateQueries(\n      createCacheKeyWithNetwork(\n        createContractCacheKey(contractAddress),\n        chainId,\n      ),\n    ),\n    queryClient.invalidateQueries(\n      createCacheKeyWithNetwork(createCachekey([\"balance\"]), chainId),\n    ),\n  ]);\n}\n\n/**\n @internal\n */\nexport const cacheKeys = {\n  network: {\n    active: (chainId: RequiredParam<SUPPORTED_CHAIN_ID>) =>\n      createCachekey([\"chainId\", chainId]),\n  },\n  wallet: {\n    balance: (tokenAddress?: ContractAddress) =>\n      createCachekey([\"balance\", { tokenAddress }]),\n  },\n  contract: {\n    type: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"contract-type\"]),\n    publishMetadata: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"publish-metadata\"]),\n    typeAndPublishMetadata: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"contract-type-and-metadata\"]),\n    metadata: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"metadata\"]),\n    extractFunctions: (contractAddress: RequiredParam<ContractAddress>) =>\n      createContractCacheKey(contractAddress, [\"extractFunctions\"]),\n\n    // specific contract types\n    nft: {\n      get: (\n        contractAddress: RequiredParam<ContractAddress>,\n        tokenId: RequiredParam<BigNumberish>,\n      ) => createContractCacheKey(contractAddress, [\"get\", { tokenId }]),\n      balanceOf: (\n        contractAddress: RequiredParam<ContractAddress>,\n        owner: RequiredParam<WalletAddress>,\n        tokenId: RequiredParam<BigNumberish>,\n      ) =>\n        createContractCacheKey(contractAddress, [\n          \"balanceOf\",\n          { owner, tokenId },\n        ]),\n      query: {\n        all: (\n          contractAddress: RequiredParam<ContractAddress>,\n          params?: QueryAllParams,\n        ) =>\n          createContractCacheKey(\n            contractAddress,\n            params ? [\"query\", \"all\", params] : [\"query\", \"all\"],\n          ),\n        totalCirculatingSupply: (\n          contractAddress: RequiredParam<ContractAddress>,\n        ) =>\n          createContractCacheKey(contractAddress, [\n            \"query\",\n            \"totalCirculatingSupply\",\n          ]),\n        owned: {\n          all: (\n            contractAddress: RequiredParam<ContractAddress>,\n            owner: RequiredParam<WalletAddress>,\n          ) =>\n            createContractCacheKey(contractAddress, [\n              \"query\",\n              \"owned\",\n              \"all\",\n              owner,\n            ]),\n        },\n      },\n      drop: {\n        getAllUnclaimed: (\n          contractAddress: RequiredParam<ContractAddress>,\n          params?: QueryAllParams,\n        ) =>\n          createContractCacheKey(\n            contractAddress,\n            params ? [\"getAllUnclaimed\", params] : [\"getAllUnclaimed\"],\n          ),\n        totalUnclaimedSupply: (\n          contractAddress: RequiredParam<ContractAddress>,\n        ) => createContractCacheKey(contractAddress, [\"totalUnclaimedSupply\"]),\n        totalClaimedSupply: (contractAddress: RequiredParam<ContractAddress>) =>\n          createContractCacheKey(contractAddress, [\"totalClaimedSupply\"]),\n      },\n    },\n\n    token: {\n      totalSupply: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"totalSupply\"]),\n      balanceOf: (\n        contractAddress: RequiredParam<ContractAddress>,\n        walletAddress: RequiredParam<ContractAddress>,\n      ) =>\n        createContractCacheKey(contractAddress, [\n          \"balanceOf\",\n          { walletAddress },\n        ]),\n    },\n    marketplace: {\n      getListing: (\n        contractAddress: RequiredParam<ContractAddress>,\n        listingId: RequiredParam<BigNumberish>,\n      ) =>\n        createContractCacheKey(contractAddress, [\"getListing\", { listingId }]),\n      getAllListings: (\n        contractAddress: RequiredParam<ContractAddress>,\n        params?: MarketplaceFilter,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          params ? [\"getAllListings\", params] : [\"getAllListings\"],\n        ),\n      getActiveListings: (\n        contractAddress: RequiredParam<ContractAddress>,\n        params?: MarketplaceFilter,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          params ? [\"getActiveListings\", params] : [\"getActiveListings\"],\n        ),\n      getBidBufferBps: (contractAddress: RequiredParam<ContractAddress>) =>\n        createContractCacheKey(contractAddress, [\"getBidBufferBps\"]),\n\n      auction: {\n        getWinningBid: (\n          contractAddress: RequiredParam<ContractAddress>,\n          listingId: RequiredParam<BigNumberish>,\n        ) =>\n          createContractCacheKey(contractAddress, [\n            \"auction\",\n            \"getWinningBid\",\n            { listingId },\n          ]),\n        getWinner: (\n          contractAddress: RequiredParam<ContractAddress>,\n          listingId: RequiredParam<BigNumberish>,\n        ) =>\n          createContractCacheKey(contractAddress, [\n            \"auction\",\n            \"getWinner\",\n            { listingId },\n          ]),\n      },\n    },\n  },\n  // extensions\n  extensions: {\n    claimConditions: {\n      getActive: (\n        contractAddress: RequiredParam<ContractAddress>,\n        tokenId?: BigNumberish,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          tokenId\n            ? [\"claimConditions\", \"getActive\", { tokenId }]\n            : [\"claimConditions\", \"getActive\"],\n        ),\n      getAll: (\n        contractAddress: RequiredParam<ContractAddress>,\n        tokenId?: BigNumberish,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          tokenId\n            ? [\"claimConditions\", \"getActive\", { tokenId }]\n            : [\"claimConditions\", \"getActive\"],\n        ),\n      getClaimIneligibilityReasons: (\n        contractAddress: RequiredParam<ContractAddress>,\n        params: { walletAddress?: WalletAddress; quantity: string | number },\n        tokenId?: BigNumberish,\n      ) =>\n        createContractCacheKey(\n          contractAddress,\n          tokenId\n            ? [\"claimConditions\", \"getActive\", { tokenId }, params]\n            : [\"claimConditions\", \"getActive\", params],\n        ),\n    },\n  },\n} as const;\n","import { useActiveChainId } from \"../../Provider\";\nimport { createCacheKeyWithNetwork } from \"../../utils/cache-keys\";\nimport {\n  QueryFunction,\n  QueryKey,\n  UseQueryOptions,\n  UseQueryResult,\n  useQuery,\n} from \"react-query\";\n\n/** @internal */\nexport function useQueryWithNetwork<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    \"queryKey\" | \"queryFn\"\n  >,\n): UseQueryResult<TData, TError> {\n  const activeChainId = useActiveChainId();\n\n  const mergedOptions: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    \"queryKey\" | \"queryFn\"\n  > = {\n    ...options,\n    enabled: !!(activeChainId && options?.enabled),\n  };\n\n  return useQuery<TQueryFnData, TError, TData, TQueryKey>(\n    createCacheKeyWithNetwork(queryKey, activeChainId) as TQueryKey,\n    queryFn,\n    mergedOptions,\n  );\n}\n","import { useActiveChainId, useSDK } from \"../../Provider\";\nimport { ContractAddress, RequiredParam } from \"../../types\";\nimport { cacheKeys, createCacheKeyWithNetwork } from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport type { ThirdwebSDK } from \"@thirdweb-dev/sdk\";\n// eslint-disable-next-line no-duplicate-imports\nimport { CONTRACTS_MAP, SmartContract } from \"@thirdweb-dev/sdk\";\nimport type {\n  CustomContractMetadata,\n  PublishedMetadata,\n} from \"@thirdweb-dev/sdk/dist/src/schema/contracts/custom\";\nimport { QueryClient, useQueryClient } from \"react-query\";\nimport invariant from \"tiny-invariant\";\n\nasync function fetchContractType(\n  contractAddress: RequiredParam<string>,\n  sdk: RequiredParam<ThirdwebSDK>,\n) {\n  if (!contractAddress || !sdk) {\n    return;\n  }\n  try {\n    return await sdk.resolveContractType(contractAddress);\n  } catch (err) {\n    // expected error, return custom type instead\n    return \"custom\" as const;\n  }\n}\n\nasync function fetchContractPublishMetadata(\n  contractAddress: RequiredParam<string>,\n  sdk: RequiredParam<ThirdwebSDK>,\n) {\n  if (!contractAddress || !sdk) {\n    return;\n  }\n\n  return await (\n    await sdk.getPublisher()\n  ).fetchContractMetadataFromAddress(contractAddress);\n}\nasync function fetchContractTypeAndPublishMetadata(\n  queryClient: QueryClient,\n  contractAddress?: string,\n  sdk?: ThirdwebSDK,\n) {\n  if (!contractAddress || !sdk) {\n    return;\n  }\n  const contractType = await queryClient.fetchQuery(\n    createCacheKeyWithNetwork(\n      cacheKeys.contract.type(contractAddress),\n      (sdk as any)._chainId,\n    ),\n    () => fetchContractType(contractAddress, sdk),\n    // is immutable, so infinite stale time\n    { staleTime: Infinity },\n  );\n  if (contractType !== \"custom\") {\n    return {\n      contractType,\n      publishMetadata: null,\n    };\n  }\n  const publishMetadata = await queryClient.fetchQuery(\n    createCacheKeyWithNetwork(\n      cacheKeys.contract.publishMetadata(contractAddress),\n      (sdk as any)._chainId,\n    ),\n    () => fetchContractPublishMetadata(contractAddress, sdk),\n    // is immutable, so infinite stale time\n    { staleTime: Infinity },\n  );\n  return {\n    contractType,\n    publishMetadata,\n  };\n}\n\nfunction getContractAbi(\n  input: RequiredParam<\n    Awaited<ReturnType<typeof fetchContractTypeAndPublishMetadata>>\n  >,\n) {\n  if (!input || !input.contractType) {\n    return null;\n  }\n  let contractAbi: PublishedMetadata[\"abi\"] | null = null;\n  if (input.contractType !== \"custom\") {\n    contractAbi = CONTRACTS_MAP[input.contractType].contractAbi;\n  }\n  if (input.contractType === \"custom\" && input.publishMetadata) {\n    contractAbi = input.publishMetadata?.abi;\n  }\n\n  return contractAbi;\n}\n\nfunction getContractFromCombinedTypeAndPublishMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n  input: RequiredParam<\n    Awaited<ReturnType<typeof fetchContractTypeAndPublishMetadata>>\n  >,\n  sdk: RequiredParam<ThirdwebSDK>,\n) {\n  if (!input || !sdk || !contractAddress || !input.contractType) {\n    return null;\n  }\n\n  const contractAbi = getContractAbi(input);\n\n  invariant(\n    contractAbi,\n    `could not resolve any ABI for contract${contractAddress}`,\n  );\n  return sdk.getContractFromAbi(contractAddress, contractAbi);\n}\n\n/**\n *\n * @internal\n *\n * @param contractAddress - contract address\n * @returns the contract abi\n */\nexport function useContractAbi(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n\n  const contractTypeAndPublishMetadata =\n    useContractTypeAndPublishMetadata(contractAddress);\n\n  if (\n    !contractAddress ||\n    !sdk ||\n    !contractTypeAndPublishMetadata.data?.contractType\n  ) {\n    return {\n      ...contractTypeAndPublishMetadata,\n      abi: null,\n    };\n  }\n\n  const abi = getContractAbi(contractTypeAndPublishMetadata.data);\n  return { ...contractTypeAndPublishMetadata, abi };\n}\n\n/**\n * Use this to get the contract type for a (built-in or custom) contract.\n *\n * @example\n * ```javascript\n * const { data: contractType, isLoading, error } = useContractType(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the contract type of the contract\n * @beta\n */\nexport function useContractType(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  return useQueryWithNetwork(\n    cacheKeys.contract.type(contractAddress),\n    () => fetchContractType(contractAddress, sdk),\n    {\n      enabled: !!sdk && !!contractAddress,\n      // never stale, a contract's publish metadata is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n\n/**\n * Use this to get the publish metadata for a deployed contract.\n *\n * @example\n * ```javascript\n * const { data: publishMetadata, isLoading, error } = useContractPublishMetadata(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the published metadata (name, abi, bytecode) of the contract\n * @beta\n */\nexport function useContractPublishMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  return useQueryWithNetwork(\n    cacheKeys.contract.publishMetadata(contractAddress),\n    () => fetchContractPublishMetadata(contractAddress, sdk),\n    {\n      enabled: !!sdk && !!contractAddress,\n      // never stale, a contract's publish metadata is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n\n/**\n * @internal\n */\nfunction useContractTypeAndPublishMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  const queryClient = useQueryClient();\n  return useQueryWithNetwork(\n    cacheKeys.contract.typeAndPublishMetadata(contractAddress),\n    () =>\n      fetchContractTypeAndPublishMetadata(queryClient, contractAddress, sdk),\n    {\n      enabled: !!sdk && !!contractAddress,\n      // combination of type and publish metadata is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n\n/**\n * Use this resolve a contract address to a thirdweb (built-in / custom) contract instance.\n *\n * @example\n * ```javascript\n * const { contract, isLoading, error } = useContract(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the contract once it is resolved\n * @beta\n */\nexport function useContract(contractAddress: RequiredParam<ContractAddress>) {\n  const sdk = useSDK();\n\n  const contractTypeAndPublishMetadata =\n    useContractTypeAndPublishMetadata(contractAddress);\n\n  if (\n    !contractAddress ||\n    !sdk ||\n    !contractTypeAndPublishMetadata.data?.contractType\n  ) {\n    return {\n      ...contractTypeAndPublishMetadata,\n      contract: null,\n    };\n  }\n\n  const contract = getContractFromCombinedTypeAndPublishMetadata(\n    contractAddress,\n    contractTypeAndPublishMetadata.data,\n    sdk,\n  );\n  return { ...contractTypeAndPublishMetadata, contract };\n}\n\n/**\n * Use this to get the contract metadata for a (built-in or custom) contract.\n *\n * @example\n * ```javascript\n * const { data: contractMetadata, isLoading, error } = useContractMetadata(\"{{contract_address}}\");\n * ```\n *\n * @param contractAddress - the address of the deployed contract\n * @returns a response object that includes the contract metadata of the deployed contract\n * @beta\n */\nexport function useContractMetadata(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  const queryClient = useQueryClient();\n  const activeChainId = useActiveChainId();\n  return useQueryWithNetwork(\n    cacheKeys.contract.metadata(contractAddress),\n    async () => {\n      const typeAndPublishMetadata = await queryClient.fetchQuery(\n        createCacheKeyWithNetwork(\n          cacheKeys.contract.typeAndPublishMetadata(contractAddress),\n          activeChainId,\n        ),\n        () =>\n          fetchContractTypeAndPublishMetadata(\n            queryClient,\n            contractAddress,\n            sdk,\n          ),\n        // is immutable, so infinite stale time\n        { staleTime: Infinity },\n      );\n      const contract = getContractFromCombinedTypeAndPublishMetadata(\n        contractAddress,\n        typeAndPublishMetadata,\n        sdk,\n      );\n      invariant(contract?.metadata?.get, \"contract metadata is not available\");\n      return (await contract.metadata.get()) as CustomContractMetadata;\n    },\n    {\n      enabled: !!contractAddress || !!sdk,\n    },\n  );\n}\n\n/**\n @internal\n */\nexport function useContractFunctions(\n  contractAddress: RequiredParam<ContractAddress>,\n) {\n  const sdk = useSDK();\n  const queryClient = useQueryClient();\n  const activeChainId = useActiveChainId();\n  return useQueryWithNetwork(\n    cacheKeys.contract.extractFunctions(contractAddress),\n    async () => {\n      const typeAndPublishMetadata = await queryClient.fetchQuery(\n        createCacheKeyWithNetwork(\n          cacheKeys.contract.typeAndPublishMetadata(contractAddress),\n          activeChainId,\n        ),\n        () =>\n          fetchContractTypeAndPublishMetadata(\n            queryClient,\n            contractAddress,\n            sdk,\n          ),\n        // is immutable, so infinite stale time\n        { staleTime: Infinity },\n      );\n      const contract = getContractFromCombinedTypeAndPublishMetadata(\n        contractAddress,\n        typeAndPublishMetadata,\n        sdk,\n      );\n      if (contract instanceof SmartContract) {\n        return contract.publishedMetadata.extractFunctions();\n      }\n      return null;\n    },\n    {\n      enabled: !!contractAddress || !!sdk,\n      // functions are based on publish metadata (abi), so this is immutable\n      staleTime: Infinity,\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport {\n  MintNFTParams,\n  MintNFTReturnType,\n  NFT,\n  NFTContract,\n  RequiredParam,\n  WalletAddress,\n  useNFTBalanceParams,\n} from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport type {\n  QueryAllParams,\n  SmartContract,\n  ValidContractInstance,\n} from \"@thirdweb-dev/sdk\";\n// eslint-disable-next-line no-duplicate-imports\nimport { Erc721, Erc1155 } from \"@thirdweb-dev/sdk\";\nimport { BigNumber, BigNumberish } from \"ethers\";\nimport { useMutation, useQueryClient } from \"react-query\";\nimport invariant from \"tiny-invariant\";\n\n/**\n @internal\n */\nexport function detectErc721Instance(\n  contract: RequiredParam<ValidContractInstance | SmartContract | null>,\n) {\n  if (!contract) {\n    return undefined;\n  }\n  if (contract instanceof Erc721) {\n    return contract;\n  }\n  if (\"nft\" in contract && contract.nft instanceof Erc721) {\n    return contract.nft;\n  }\n  return undefined;\n}\n\nexport function detectErc1155Instance(\n  contract: RequiredParam<ValidContractInstance | SmartContract | null>,\n) {\n  if (!contract) {\n    return undefined;\n  }\n  if (contract instanceof Erc1155) {\n    return contract;\n  }\n  if (\"nft\" in contract && contract.nft instanceof Erc1155) {\n    return contract.nft;\n  }\n  return undefined;\n}\n\nfunction convertResponseToNFTType(\n  contract: NFTContract,\n  metadata: Awaited<ReturnType<typeof contract[\"get\"]>>,\n): NFT<typeof contract> {\n  if (contract instanceof Erc721) {\n    return {\n      type: \"ERC721\",\n      supply: 1,\n      owner: \"\",\n      ...metadata,\n    } as NFT<Erc721>;\n  }\n  return {\n    type: \"ERC1155\",\n    supply: 0,\n    owner: \"\",\n    ...metadata,\n  } as NFT<Erc1155>;\n}\n\nfunction convertResponseToNFTTypeArray(\n  contract: NFTContract,\n  metadata: Awaited<ReturnType<typeof contract[\"get\"]>>[],\n): NFT<typeof contract>[] {\n  return metadata.map((m) => convertResponseToNFTType(contract, m));\n}\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get an individual NFT token of your {@link NFTContract}.\n *\n * @example\n * ```javascript\n * const { data: nft, isLoading, error } = useNFT(NFTContract, <tokenId>);\n * ```\n *\n * @param contract - an instace of a {@link NFTContract}\n * @param tokenId - the tokenId to look up\n * @returns a response object that includes the metadata for the given tokenId\n * @beta\n */\nexport function useNFT<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n  tokenId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork<NFT<TContract>>(\n    cacheKeys.contract.nft.get(contractAddress, tokenId),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(contract.get, \"Contract instance does not support get\");\n\n      return convertResponseToNFTType(\n        contract,\n        await contract.get(BigNumber.from(tokenId || 0)),\n      );\n    },\n    {\n      enabled: !!contract && tokenId !== undefined,\n    },\n  );\n}\n\n/**\n * Use this to get a list of NFT tokens of your {@link NFTContract}.\n *\n * @example\n * ```javascript\n * const { data: nfts, isLoading, error } = useNFTs(NFTContract, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instace of a {@link NFTContract}\n * @param queryParams - query params to pass to the query for the sake of pagination\n * @returns a response object that includes an array of NFTs\n * @beta\n */\nexport function useNFTs<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n  queryParams?: QueryAllParams,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork<NFT<TContract>[]>(\n    cacheKeys.contract.nft.query.all(contractAddress, queryParams),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.query?.all,\n        \"Contract instance does not support query.all\",\n      );\n\n      return convertResponseToNFTTypeArray(\n        contract,\n        await contract.query.all(queryParams),\n      );\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a the total (minted) supply of your {@link NFTContract}.\n *\n * @example\n * ```javascript\n * const { data: totalSupply, isLoading, error } = useNFTSupply(NFTContract);\n * ```\n *\n * @param contract - an instace of a {@link NFTContract}\n * @returns a response object that incudes the total minted supply\n * @beta\n */\nexport function useTotalCirculatingSupply(\n  contract: RequiredParam<NFTContract>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.query.totalCirculatingSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      if (contract instanceof Erc721) {\n        invariant(\n          contract?.query?.totalCirculatingSupply,\n          \"Contract instance does not support query.totalCirculatingSupply\",\n        );\n        return contract.query.totalCirculatingSupply();\n      }\n      invariant(\n        contract.query?.getTotalCount,\n        \"Contract instance does not support query.getTotalCount\",\n      );\n      return contract.query.getTotalCount();\n    },\n    {\n      enabled: !!contract,\n    },\n  );\n}\n\n/**\n * Use this to get a the owned NFTs for a specific {@link NFTContract} and wallet address.\n *\n * @example\n * ```javascript\n * const { data: ownedNFTs, isLoading, error } = useOwnedNFTs(NFTContract, <OwnerWalletAddress>);\n * ```\n *\n * @param contract - an instace of a {@link NFTContract}\n * @param ownerWalletAddress - the wallet adress to get owned tokens for\n * @returns a response object that includes the list of owned tokens\n * @beta\n */\nexport function useOwnedNFTs<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n  ownerWalletAddress: RequiredParam<WalletAddress>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork<NFT<TContract>[]>(\n    cacheKeys.contract.nft.query.owned.all(contractAddress, ownerWalletAddress),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      if (contract instanceof Erc721) {\n        invariant(\n          contract.query?.owned?.all,\n          \"Contract instance does not support query.owned.all\",\n        );\n        return convertResponseToNFTTypeArray(\n          contract,\n          await contract.query.owned.all(ownerWalletAddress),\n        );\n      }\n      invariant(\n        contract.query?.owned,\n        \"Contract instance does not support query.owned\",\n      );\n      return convertResponseToNFTTypeArray(\n        contract,\n        await contract.query.owned(ownerWalletAddress),\n      );\n    },\n    {\n      enabled: !!contract && !!ownerWalletAddress,\n    },\n  );\n}\n\n/**\n * Use this to get a the total balance of a {@link NFTContract} and wallet address.\n *\n *\n * @example\n * ```javascript\n * const { data: ownerBalance, isLoading, error } = useNFTBalance(NFTContract, <OwnerWalletAddress>);\n * ```\n *\n * @param contract - an instace of a {@link NFTContract}\n * @param ownerWalletAddress - the wallet adress to check the balance of\n * @returns a response object that includes the total balance of the owner\n * @beta\n */\nexport function useNFTBalance<TContract extends NFTContract>(\n  ...[contract, ownerWalletAddress, tokenId]: useNFTBalanceParams<TContract>\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.balanceOf(\n      contractAddress,\n      ownerWalletAddress,\n      tokenId,\n    ),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.balanceOf,\n        \"Contract instance does not support balanceOf\",\n      );\n      invariant(ownerWalletAddress, \"No owner wallet address provided\");\n      if (contract instanceof Erc1155) {\n        invariant(tokenId, \"No tokenId provided\");\n        return contract.balanceOf(ownerWalletAddress, tokenId);\n      }\n      return contract.balanceOf(ownerWalletAddress);\n    },\n    {\n      enabled: !!contract && !!ownerWalletAddress,\n    },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to mint a new NFT on your {@link NFTContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: mintNft,\n *     isLoading,\n *     error,\n *   } = useMintNFT(NFTContract);\n *\n *   if (error) {\n *     console.error(\"failed to mint nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => mintNft({ name: \"My awesome NFT!\" })}\n *     >\n *       Mint!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instace of a {@link NFTContract}\n * @returns a mutation object that can be used to mint a new NFT token to the connected wallet\n * @beta\n */\nexport function useMintNFT<TContract extends NFTContract>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: MintNFTParams<TContract>) => {\n      invariant(data.to, 'No \"to\" address provided');\n      invariant(contract?.mint?.to, \"contract does not support mint.to\");\n      if (contract instanceof Erc1155) {\n        invariant(\"supply\" in data, \"supply not provided\");\n        const { to, metadata, supply } = data;\n        return (await contract.mint.to(to, {\n          metadata,\n          supply: BigNumber.from(supply || 1),\n        })) as MintNFTReturnType<TContract>;\n      }\n      return (await contract.mint.to(\n        data.to,\n        data.metadata,\n      )) as MintNFTReturnType<TContract>;\n    },\n    {\n      onSuccess: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport {\n  ClaimNFTParams,\n  ClaimNFTReturnType,\n  DropContract,\n  RequiredParam,\n} from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useNFTs } from \"./nft\";\nimport { Erc1155, NFTDrop, QueryAllParams } from \"@thirdweb-dev/sdk\";\nimport { useMutation, useQueryClient } from \"react-query\";\nimport invariant from \"tiny-invariant\";\n\n/** **********************/\n/**       READ HOOKS    **/\n/** **********************/\n\n/**\n * Use this to get a list of *unclaimed* NFT tokens of your ERC721 Drop contract.\n *\n * @example\n * ```javascript\n * const { data: unclaimedNfts, isLoading, error } = useUnclaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instace of a contract that extends the Erc721 spec (nft drop, custom contract that follows the Erc721 & drop spec)\n * @param queryParams - query params to pass to the query for the sake of pagination\n * @returns a response object that includes an array of NFTs that are unclaimed\n * @beta\n */\nexport function useUnclaimedNFTs(\n  contract: RequiredParam<NFTDrop>,\n  queryParams?: QueryAllParams,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.drop.getAllUnclaimed(contractAddress, queryParams),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.getAllUnclaimed,\n        \"Contract instance does not support getAllUnclaimed\",\n      );\n      return contract.getAllUnclaimed(queryParams);\n    },\n    { enabled: !!contract },\n  );\n}\n\n/**\n * Use this to get a list of *claimed* (minted) NFT tokens of your ERC721 Drop contract.\n *\n * @remarks Equivalent to using {@link useNFTs}.\n *\n * @example\n * ```javascript\n * const { data: claimedNFTs, isLoading, error } = useClaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instace of a {@link DropContract}\n * @param queryParams - query params to pass to the query for the sake of pagination\n * @returns a response object that includes an array of NFTs that are claimed\n * @beta\n */\nexport function useClaimedNFTs(\n  contract: RequiredParam<DropContract>,\n  queryParams?: QueryAllParams,\n) {\n  return useNFTs(contract, queryParams);\n}\n/**\n *\n * @param contract - an instace of a {@link NFTDrop}\n * @returns a response object that includes the number of NFTs that are unclaimed\n */\nexport function useUnclaimedNFTSupply(contract: RequiredParam<NFTDrop>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.drop.totalUnclaimedSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n\n      invariant(\n        contract.totalUnclaimedSupply,\n        \"Contract instance does not support totalUnclaimedSupply\",\n      );\n      return contract.totalUnclaimedSupply();\n    },\n    { enabled: !!contract },\n  );\n}\n\n/**\n *\n * @param contract - an instace of a {@link DropContract}\n * @returns a response object that includes the number of NFTs that are claimed\n */\nexport function useClaimedNFTSupply(contract: RequiredParam<DropContract>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.nft.drop.totalClaimedSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      if (contract instanceof Erc1155) {\n        return contract.getTotalCount();\n      }\n      invariant(\n        contract.totalClaimedSupply,\n        \"Contract instance does not support totalClaimedSupply\",\n      );\n      return contract.totalClaimedSupply();\n    },\n    { enabled: !!contract },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n/**\n * Use this to mint a new NFT on your {@link DropContract}\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: claimNft,\n *     isLoading,\n *     error,\n *   } = useClaimNFT(DropContract);\n *\n *   if (error) {\n *     console.error(\"failed to mint nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => claimNft({to: \"0x...\", quantity: 1})}\n *     >\n *       Mint!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instace of a {@link DropContract}\n * @returns a mutation object that can be used to mint a new NFT token to the connected wallet\n * @beta\n */\nexport function useClaimNFT<TContract extends DropContract>(\n  contract: RequiredParam<TContract>,\n) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    async (data: ClaimNFTParams<TContract>) => {\n      invariant(data.to, 'No \"to\" address provided');\n      invariant(contract?.claimTo, \"contract does not support claimTo\");\n      if (contract instanceof Erc1155) {\n        invariant(\"tokenId\" in data, \"tokenId not provided\");\n        const { to, tokenId, quantity, proofs } = data;\n        return (await contract.claimTo(\n          to,\n          tokenId,\n          quantity,\n          proofs,\n        )) as ClaimNFTReturnType<TContract>;\n      }\n      return (await contract.claimTo(\n        data.to,\n        data.quantity,\n        data.proofs,\n      )) as ClaimNFTReturnType<TContract>;\n    },\n    {\n      onSuccess: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport { BuyNowParams, MakeBidParams, RequiredParam } from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useAddress } from \"../useAddress\";\nimport type {\n  Marketplace,\n  MarketplaceFilter,\n  NewAuctionListing,\n  NewDirectListing,\n} from \"@thirdweb-dev/sdk\";\n// eslint-disable-next-line no-duplicate-imports\nimport { ListingType } from \"@thirdweb-dev/sdk\";\nimport { BigNumber, BigNumberish } from \"ethers\";\nimport { useMutation, useQueryClient } from \"react-query\";\nimport invariant from \"tiny-invariant\";\n\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get a specific listing from the marketplace.\n *\n * @example\n * ```javascript\n * const { data: listing, isLoading, error } = useListing(<YourMarketplaceContractInstance>, <listingId>);\n * ```\n *\n * @param contract - an instace of a marketplace contract\n * @param listingId - the listing id to check\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useListing(\n  contract: RequiredParam<Marketplace>,\n  listingId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getListing(contractAddress, listingId),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.getListing(BigNumber.from(listingId || 0));\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a list all listings from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: listings, isLoading, error } = useListings(<YourMarketplaceContractInstance>, { start: 0, count: 100 });\n * ```\n *\n * @param contract - an instace of a marketplace contract\n * @param filter - filter to pass to the query for the sake of pagination & filtering\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useListings(\n  contract: RequiredParam<Marketplace>,\n  filter?: MarketplaceFilter,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getAllListings(contractAddress, filter),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.getAllListings(filter);\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a list active listings from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: listings, isLoading, error } = useMarketplaceListings(<YourMarketplaceContractInstance>, { seller: \"0x...\", tokenContract: \"0x...\", tokenId: 1, start: 0, count: 100 });\n * ```\n *\n * @param contract - an instace of a marketplace contract\n * @param filter - filter to pass to the query for the sake of pagination & filtering\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useActiveListings(\n  contract: RequiredParam<Marketplace>,\n  filter?: MarketplaceFilter,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getActiveListings(contractAddress, filter),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n\n      return contract.getActiveListings(filter);\n    },\n    {\n      enabled: !!contract || !contractAddress,\n      keepPreviousData: true,\n    },\n  );\n}\n\n/**\n * Use this to get a the winning bid for an auction listing from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: winningBid, isLoading, error } = useWinningBid(<YourMarketplaceContractInstance>, <listingId>);\n * ```\n *\n * @param contract - an instace of a marketplace contract\n * @param listingId - the listing id to check\n * @returns a response object that includes the {@link Offer} that is winning the auction\n * @beta\n */\nexport function useWinningBid(\n  contract: RequiredParam<Marketplace>,\n  listingId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.auction.getWinningBid(\n      contractAddress,\n      listingId,\n    ),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.auction.getWinningBid(BigNumber.from(listingId || 0));\n    },\n    {\n      enabled: !!contract && listingId !== undefined,\n    },\n  );\n}\n\n/**\n * Use this to get the winner of an auction listing from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: auctionWinner, isLoading, error } = useAuctionWinner(<YourMarketplaceContractInstance>, <listingId>);\n * ```\n *\n * @param contract - an instace of a marketplace contract\n * @param listingId - the listing id to check\n * @returns a response object that includes the address of the winner of the auction or undefined if there is no winner yet\n * @beta\n */\nexport function useAuctionWinner(\n  contract: RequiredParam<Marketplace>,\n  listingId: RequiredParam<BigNumberish>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.auction.getWinner(\n      contractAddress,\n      listingId,\n    ),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      let winner: string | undefined;\n      try {\n        winner = await contract.auction.getWinner(\n          BigNumber.from(listingId || 0),\n        );\n      } catch (err) {\n        if (!(err as Error)?.message?.includes(\"Could not find auction\")) {\n          throw err;\n        }\n      }\n      return winner;\n    },\n    {\n      enabled: !!contract && listingId !== undefined,\n    },\n  );\n}\n\n/**\n * Use this to get the buffer in basis points between offers from your marketplace contract.\n *\n * @example\n * ```javascript\n * const { data: auctionWinner, isLoading, error } = useAuctionWinner(<YourMarketplaceContractInstance>, <listingId>);\n * ```\n *\n * @param contract - an instace of a marketplace contract\n\n * @returns a response object that includes an array of listings\n * @beta\n */\nexport function useBidBuffer(contract: RequiredParam<Marketplace>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.marketplace.getBidBufferBps(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.getBidBufferBps();\n    },\n    {\n      enabled: !!contract,\n    },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to create a new Direct Listing on your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: createDirectListing,\n *     isLoading,\n *     error,\n *   } = useCreateDirectListing(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to create direct listing\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => createDirectListing(directListingData)}\n *     >\n *       Create Direct Listing!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instace of a Marketplace contract\n * @returns a mutation object that can be used to create a new direct listing\n * @beta\n */\nexport function useCreateDirectListing(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: NewDirectListing) => {\n      invariant(walletAddress, \"no wallet connected, cannot create listing\");\n      invariant(\n        contract?.direct?.createListing,\n        \"contract does not support direct.createListing\",\n      );\n      return await contract.direct.createListing(data);\n    },\n    {\n      onSuccess: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to create a new Auction Listing on your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: createAuctionListing,\n *     isLoading,\n *     error,\n *   } = useCreateAuctionListing(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to create auction listing\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => createAuctionListing(auctionListingData)}\n *     >\n *       Create Auction Listing!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instace of a Marketplace contract\n * @returns a mutation object that can be used to create a new auction listing\n * @beta\n */\nexport function useCreateAuctionListing(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: NewAuctionListing) => {\n      invariant(walletAddress, \"no wallet connected, cannot create listing\");\n      invariant(\n        contract?.direct?.createListing,\n        \"contract does not support auction.createListing\",\n      );\n      return await contract.auction.createListing(data);\n    },\n    {\n      onSuccess: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to place a bid on an auction listing from your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: makeBid,\n *     isLoading,\n *     error,\n *   } = useMakeBid(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to make a bid\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => makeBid({ listingId: 1, bid: 2 })}\n *     >\n *       Bid!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instace of a Marketplace contract\n * @returns a mutation object that can be used to make a bid on an auction listing\n * @beta\n */\nexport function useMakeBid(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: MakeBidParams) => {\n      invariant(walletAddress, \"no wallet connected, cannot make bid\");\n      invariant(\n        contract?.auction?.makeBid,\n        \"contract does not support auction.makeBid\",\n      );\n      return await contract.auction.makeBid(data.listingId, data.bid);\n    },\n    {\n      onSuccess: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n\n/**\n * Use this to buy out an auction listing from your marketplace contract.\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: buyNow,\n *     isLoading,\n *     error,\n *   } = useBuyNow(\">>YourMarketplaceContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to buyout listing\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => buyNow({listingId: 1, type: ListingType.Auction})}\n *     >\n *       Buy listing!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instace of a Marketplace contract\n * @returns a mutation object that can be used to buy out an auction listing\n * @beta\n */\nexport function useBuyNow(contract: RequiredParam<Marketplace>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n  const walletAddress = useAddress();\n  return useMutation(\n    async (data: BuyNowParams) => {\n      invariant(walletAddress, \"no wallet connected, cannot make bid\");\n      if (data.type === ListingType.Direct) {\n        invariant(\n          contract?.direct.buyoutListing,\n          \"contract does not support direct.buyoutListing\",\n        );\n\n        return await contract.direct.buyoutListing(\n          data.id,\n          data.buyAmount,\n          data.buyForWallet,\n        );\n      }\n      invariant(\n        contract?.auction?.buyoutListing,\n        \"contract does not support auction.buyoutListing\",\n      );\n      return await contract.auction.buyoutListing(data.id);\n    },\n    {\n      onSuccess: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { useActiveChainId } from \"../../Provider\";\nimport { RequiredParam, TokenMintParams, WalletAddress } from \"../../types\";\nimport {\n  cacheKeys,\n  invalidateContractAndBalances,\n} from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport type { Erc20 } from \"@thirdweb-dev/sdk\";\nimport { useMutation, useQueryClient } from \"react-query\";\nimport invariant from \"tiny-invariant\";\n\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get a the total supply of your Token contract.\n *\n * @example\n * ```javascript\n * const { data: totalSupply, isLoading, error } = useTokenSupply(<YourTokenContractInstance>);\n * ```\n *\n * @param contract - an instace of a Token contract.\n * @returns a response object that incudes the total minted supply\n * @beta\n */\nexport function useTokenSupply(contract: RequiredParam<Erc20>) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.token.totalSupply(contractAddress),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      return contract.totalSupply();\n    },\n    {\n      enabled: !!contract || !!contractAddress,\n    },\n  );\n}\n\n/**\n * Use this to get the balance of your Token contract for a given address.\n *\n * @example\n * ```javascript\n * const { data: balance, isLoading, error } = useTokenBalance(<YourTokenContractInstance>);\n * ```\n *\n * @param contract - an instace of a Token contract.\n * @returns a response object that includes the balance of the address\n * @beta\n */\nexport function useTokenBalance(\n  contract: RequiredParam<Erc20>,\n  walletAddress: RequiredParam<WalletAddress>,\n) {\n  const contractAddress = contract?.getAddress();\n  return useQueryWithNetwork(\n    cacheKeys.contract.token.balanceOf(contractAddress, walletAddress),\n    async () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(walletAddress, \"No address provided\");\n      return await contract.balanceOf(walletAddress);\n    },\n    {\n      enabled: !!walletAddress && !!contract,\n    },\n  );\n}\n\n/** **********************/\n/**     WRITE HOOKS     **/\n/** **********************/\n\n/**\n * Use this to mint a new NFT on your ERC20 contract\n *\n * @example\n * ```jsx\n * const Component = () => {\n *   const {\n *     mutate: mintNft,\n *     isLoading,\n *     error,\n *   } = useMintToken(\">>YourERC20ContractInstance<<\");\n *\n *   if (error) {\n *     console.error(\"failed to mint nft\", error);\n *   }\n *\n *   return (\n *     <button\n *       disabled={isLoading}\n *       onClick={() => mintNft({ name: \"My awesome NFT!\" })}\n *     >\n *       Mint!\n *     </button>\n *   );\n * };\n * ```\n *\n * @param contract - an instace of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)\n * @returns a mutation object that can be used to mint a new NFT token to the connected wallet\n * @beta\n */\nexport function useMintToken(contract: RequiredParam<Erc20>) {\n  const activeChainId = useActiveChainId();\n  const contractAddress = contract?.getAddress();\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    (data: TokenMintParams) => {\n      const { to, amount } = data;\n      invariant(contract?.mint?.to, \"contract does not support mint.to\");\n      return contract.mint.to(to, amount);\n    },\n    {\n      onSuccess: () =>\n        invalidateContractAndBalances(\n          queryClient,\n          contractAddress,\n          activeChainId,\n        ),\n    },\n  );\n}\n","import { RequiredParam, WalletAddress } from \"../../types\";\nimport { cacheKeys } from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { EditionDrop, Erc1155, NFTDrop, TokenDrop } from \"@thirdweb-dev/sdk\";\nimport { BigNumberish } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\ntype ActiveClaimConditionParams<TContract> = TContract extends Erc1155\n  ? [contract: RequiredParam<TContract>, tokenId: RequiredParam<BigNumberish>]\n  : [contract: RequiredParam<TContract>];\n\n/** **********************/\n/**     READ  HOOKS     **/\n/** **********************/\n\n/**\n * Use this to get the active claim conditon for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.\n *\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC20ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC721ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC1155ContractInstance>, <tokenId>);\n * ```\n *\n * @param contract - an instace of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.\n * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)\n * @returns a response object with the currently active claim condition\n *\n * @beta\n */\nexport function useActiveClaimCondition<\n  TContract extends NFTDrop | EditionDrop | TokenDrop,\n>(...[contract, tokenId]: ActiveClaimConditionParams<TContract>) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork(\n    cacheKeys.extensions.claimConditions.getActive(contractAddress, tokenId),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.claimConditions.getActive,\n        \"Contract instance does not support claimConditions.getActive\",\n      );\n      if (contract instanceof Erc1155) {\n        invariant(tokenId, \"tokenId is required for ERC1155 claim conditions\");\n        return contract.claimConditions.getActive(tokenId);\n      }\n      return contract.claimConditions.getActive();\n    },\n    {\n      // Checks that happen here:\n      // 1. if the contract is based on  ERC1155 contract => tokenId cannot be `undefined`\n      // 2. if the contract is NOT based on ERC1155 => contract has to still be provided\n      enabled: contract instanceof Erc1155 ? tokenId !== undefined : !!contract,\n    },\n  );\n}\n\n/**\n * Use this to get all claim conditons for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.\n *\n * @example\n * ```javascript\n * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC20ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC721ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC1155ContractInstance>, <tokenId>);\n * ```\n *\n * @param contract - an instace of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.\n * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)\n * @returns a response object with the list of claim conditions\n *\n * @beta\n */\nexport function useClaimConditions<\n  TContract extends NFTDrop | EditionDrop | TokenDrop,\n>(...[contract, tokenId]: ActiveClaimConditionParams<TContract>) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork(\n    cacheKeys.extensions.claimConditions.getAll(contractAddress, tokenId),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.claimConditions.getAll,\n        \"Contract instance does not support claimConditions.getAll\",\n      );\n      if (contract instanceof Erc1155) {\n        invariant(tokenId, \"tokenId is required for ERC1155 claim conditions\");\n        return contract.claimConditions.getAll(tokenId);\n      }\n      return contract.claimConditions.getAll();\n    },\n    {\n      // Checks that happen here:\n      // 1. if the contract is based on  ERC1155 contract => tokenId cannot be `undefined`\n      // 2. if the contract is NOT based on ERC1155 => contract has to still be provided\n      enabled: contract instanceof Erc1155 ? tokenId !== undefined : !!contract,\n    },\n  );\n}\n\n/**\n * The options to be passed as the second parameter to the `useClaimIneligibilityReasons` hook.\n *\n * @beta\n */\nexport type ClaimIneligibilityParameters = {\n  // the wallet address to check claim elgibility for\n  walletAddress?: WalletAddress;\n  // the amount of tokens to check claim elibility for\n  quantity: string | number;\n};\n\ntype ClaimIneligibilityInputParams<TContract> = TContract extends Erc1155\n  ? [\n      contract: RequiredParam<TContract>,\n      eligibilityParams: ClaimIneligibilityParameters,\n      tokenId: RequiredParam<BigNumberish>,\n    ]\n  : [\n      contract: RequiredParam<TContract>,\n      eligibilityParams: ClaimIneligibilityParameters,\n    ];\n\n/**\n * Use this to check for reasons that prevent claiming for either  ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.\n * @example\n * ```javascript\n * const { data: activeClaimCondition, isLoading, error } = useClaimIneligibilityReasons(<YourERC20ContractInstance>);\n * ```\n * @example\n * ```javascript\n * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC721ContractInstance>, {quantity: <quantity>});\n * ```\n * @example\n * ```javascript\n * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC1155ContractInstance>, {quantity: <quantity>}, <tokenId>);\n * ```\n *\n * @param contract - an instace of a contract that extends the  ERC20, ERC721 or ERC1155 spec and implements the `claimConditions` extension.\n * @param eligibilityParams - the parameters for the eligibility check, see: {@link ClaimIneligibilityParameters}\n * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)\n * @returns a response object with the resons for the claim ineligibility\n *\n * @beta\n */\nexport function useClaimIneligibilityReasons<\n  TContract extends NFTDrop | EditionDrop | TokenDrop,\n>(...[contract, params, tokenId]: ClaimIneligibilityInputParams<TContract>) {\n  const contractAddress = contract?.getAddress();\n\n  return useQueryWithNetwork(\n    cacheKeys.extensions.claimConditions.getClaimIneligibilityReasons(\n      contractAddress,\n      params,\n      tokenId,\n    ),\n    () => {\n      invariant(contract, \"No Contract instance provided\");\n      invariant(\n        contract.claimConditions.getClaimIneligibilityReasons,\n        \"Contract instance does not support claimConditions.getClaimIneligibilityReasons\",\n      );\n      if (contract instanceof Erc1155) {\n        invariant(\n          tokenId,\n          \"tokenId is required for ERC1155 claim ineligibility reasons\",\n        );\n        return contract.claimConditions.getClaimIneligibilityReasons(\n          tokenId,\n          params.quantity,\n          params.walletAddress,\n        );\n      }\n      return contract.claimConditions.getClaimIneligibilityReasons(\n        params.quantity,\n        params.walletAddress,\n      );\n    },\n    {\n      // Checks that happen here:\n      // 1. if the contract is based on  ERC1155 contract => tokenId cannot be `undefined`\n      // 2. if the contract is NOT based on ERC1155 => contract has to still be provided\n      // 3. has a params object been passed?\n      // 4. does params have an address in it?\n      enabled:\n        (contract instanceof Erc1155 ? tokenId !== undefined : !!contract) &&\n        !!params &&\n        !!params.walletAddress,\n    },\n  );\n}\n","import { useSDK } from \"../../Provider\";\nimport { ContractAddress } from \"../../types\";\nimport { cacheKeys } from \"../../utils/cache-keys\";\nimport { useQueryWithNetwork } from \"../query-utils/useQueryWithNetwork\";\nimport { useAddress } from \"../useAddress\";\nimport invariant from \"tiny-invariant\";\n\nexport function useBalance(tokenAddress?: ContractAddress) {\n  const sdk = useSDK();\n  const address = useAddress();\n  return useQueryWithNetwork(\n    cacheKeys.wallet.balance(tokenAddress),\n    () => {\n      invariant(sdk, \"No SDK instance provided\");\n      return sdk.wallet.balance(tokenAddress);\n    },\n    {\n      // if user is not logged in no reason to try to fetch\n      enabled: !!address,\n    },\n  );\n}\n"],"mappings":"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","names":[]}