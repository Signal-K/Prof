import EventEmitter from 'eventemitter3';
import { a as alchemyRpcUrls, i as infuraRpcUrls, d as defaultAlchemyId } from './rpcs-7cfbd91c.esm.js';

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }

  return descriptor.value;
}

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }

  return privateMap.get(receiver);
}

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}

function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return fn;
}

function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }

    descriptor.value = value;
  }
}

function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}

const etherscanBlockExplorers = {
  mainnet: {
    name: 'Etherscan',
    url: 'https://etherscan.io'
  },
  ropsten: {
    name: 'Etherscan',
    url: 'https://ropsten.etherscan.io'
  },
  rinkeby: {
    name: 'Etherscan',
    url: 'https://rinkeby.etherscan.io'
  },
  goerli: {
    name: 'Etherscan',
    url: 'https://goerli.etherscan.io'
  },
  kovan: {
    name: 'Etherscan',
    url: 'https://kovan.etherscan.io'
  },
  optimism: {
    name: 'Etherscan',
    url: 'https://optimistic.etherscan.io'
  },
  optimismKovan: {
    name: 'Etherscan',
    url: 'https://kovan-optimistic.etherscan.io'
  },
  polygon: {
    name: 'PolygonScan',
    url: 'https://polygonscan.com'
  },
  polygonMumbai: {
    name: 'PolygonScan',
    url: 'https://mumbai.polygonscan.com'
  },
  arbitrum: {
    name: 'Arbiscan',
    url: 'https://arbiscan.io'
  },
  arbitrumRinkeby: {
    name: 'Arbiscan',
    url: 'https://testnet.arbiscan.io'
  }
};

const chainId = {
  mainnet: 1,
  ropsten: 3,
  rinkeby: 4,
  goerli: 5,
  kovan: 42,
  optimism: 10,
  optimismKovan: 69,
  polygon: 137,
  polygonMumbai: 80001,
  arbitrum: 42161,
  arbitrumRinkeby: 421611,
  localhost: 1337,
  hardhat: 31337
};
const chain = {
  mainnet: {
    id: chainId.mainnet,
    name: 'Ethereum',
    network: 'homestead',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.mainnet,
      infura: infuraRpcUrls.mainnet,
      default: "".concat(alchemyRpcUrls.mainnet, "/").concat(defaultAlchemyId)
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.mainnet,
      default: etherscanBlockExplorers.mainnet
    }
  },
  ropsten: {
    id: chainId.ropsten,
    name: 'Ropsten',
    network: 'ropsten',
    nativeCurrency: {
      name: 'Ropsten Ether',
      symbol: 'ropETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.ropsten,
      infura: infuraRpcUrls.ropsten,
      default: "".concat(alchemyRpcUrls.ropsten, "/").concat(defaultAlchemyId)
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.ropsten,
      default: etherscanBlockExplorers.ropsten
    },
    testnet: true
  },
  rinkeby: {
    id: chainId.rinkeby,
    name: 'Rinkeby',
    network: 'rinkeby',
    nativeCurrency: {
      name: 'Rinkeby Ether',
      symbol: 'rETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.rinkeby,
      infura: infuraRpcUrls.rinkeby,
      default: "".concat(alchemyRpcUrls.rinkeby, "/").concat(defaultAlchemyId)
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.rinkeby,
      default: etherscanBlockExplorers.rinkeby
    },
    testnet: true
  },
  goerli: {
    id: chainId.goerli,
    name: 'Goerli',
    network: 'goerli',
    nativeCurrency: {
      name: 'Goerli Ether',
      symbol: 'gETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.goerli,
      infura: infuraRpcUrls.goerli,
      default: "".concat(alchemyRpcUrls.goerli, "/").concat(defaultAlchemyId)
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.goerli,
      default: etherscanBlockExplorers.goerli
    },
    testnet: true
  },
  kovan: {
    id: chainId.kovan,
    name: 'Kovan',
    network: 'kovan',
    nativeCurrency: {
      name: 'Kovan Ether',
      symbol: 'kETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.kovan,
      infura: infuraRpcUrls.kovan,
      default: "".concat(alchemyRpcUrls.kovan, "/").concat(defaultAlchemyId)
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.kovan,
      default: etherscanBlockExplorers.kovan
    },
    testnet: true
  },
  optimism: {
    id: chainId.optimism,
    name: 'Optimism',
    network: 'optimism',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.optimism,
      infura: infuraRpcUrls.optimism,
      default: 'https://mainnet.optimism.io'
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.optimism,
      default: etherscanBlockExplorers.optimism
    }
  },
  optimismKovan: {
    id: chainId.optimismKovan,
    name: 'Optimism Kovan',
    network: 'optimism-kovan',
    nativeCurrency: {
      name: 'Kovan Ether',
      symbol: 'KOR',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.optimismKovan,
      infura: infuraRpcUrls.optimismKovan,
      default: 'https://kovan.optimism.io'
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.optimismKovan,
      default: etherscanBlockExplorers.optimismKovan
    },
    testnet: true
  },
  polygon: {
    id: chainId.polygon,
    name: 'Polygon',
    network: 'matic',
    nativeCurrency: {
      name: 'MATIC',
      symbol: 'MATIC',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.polygon,
      infura: infuraRpcUrls.polygon,
      default: 'https://polygon-rpc.com'
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.polygon,
      default: etherscanBlockExplorers.polygon
    }
  },
  polygonMumbai: {
    id: chainId.polygonMumbai,
    name: 'Polygon Mumbai',
    network: 'maticmum',
    nativeCurrency: {
      name: 'MATIC',
      symbol: 'MATIC',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.polygonMumbai,
      infura: infuraRpcUrls.polygonMumbai,
      default: 'https://matic-mumbai.chainstacklabs.com'
    },
    blockExplorers: {
      etherscan: etherscanBlockExplorers.polygonMumbai,
      default: etherscanBlockExplorers.polygonMumbai
    },
    testnet: true
  },
  arbitrum: {
    id: chainId.arbitrum,
    name: 'Arbitrum',
    network: 'arbitrum',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'AETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.arbitrum,
      infura: infuraRpcUrls.arbitrum,
      default: 'https://arb1.arbitrum.io/rpc'
    },
    blockExplorers: {
      arbitrum: {
        name: 'Arbitrum Explorer',
        url: 'https://explorer.arbitrum.io'
      },
      etherscan: etherscanBlockExplorers.arbitrum,
      default: etherscanBlockExplorers.arbitrum
    }
  },
  arbitrumRinkeby: {
    id: chainId.arbitrumRinkeby,
    name: 'Arbitrum Rinkeby',
    network: 'arbitrum-rinkeby',
    nativeCurrency: {
      name: 'Arbitrum Rinkeby Ether',
      symbol: 'ARETH',
      decimals: 18
    },
    rpcUrls: {
      alchemy: alchemyRpcUrls.arbitrumRinkeby,
      infura: infuraRpcUrls.arbitrumRinkeby,
      default: 'https://rinkeby.arbitrum.io/rpc'
    },
    blockExplorers: {
      arbitrum: {
        name: 'Arbitrum Explorer',
        url: 'https://rinkeby-explorer.arbitrum.io'
      },
      etherscan: etherscanBlockExplorers.arbitrumRinkeby,
      default: etherscanBlockExplorers.arbitrumRinkeby
    },
    testnet: true
  },
  localhost: {
    id: chainId.localhost,
    name: 'Localhost',
    network: 'localhost',
    rpcUrls: {
      default: 'http://127.0.0.1:8545'
    }
  },
  hardhat: {
    id: chainId.hardhat,
    name: 'Hardhat',
    network: 'hardhat',
    rpcUrls: {
      default: 'http://127.0.0.1:8545'
    }
  }
};
const allChains = Object.values(chain);
const defaultChains = [chain.mainnet, chain.ropsten, chain.rinkeby, chain.goerli, chain.kovan];
const defaultL2Chains = [chain.arbitrum, chain.arbitrumRinkeby, chain.optimism, chain.optimismKovan];

function normalizeChainId(chainId) {
  if (typeof chainId === 'string') return Number.parseInt(chainId, chainId.trim().substring(0, 2) === '0x' ? 16 : 10);
  return chainId;
}

/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.
 * @see https://eips.ethereum.org/EIPS/eip-1474
 */
class RpcError extends Error {
  constructor(
  /** Number error code */
  code,
  /** Human-readable string */
  message,
  /** Low-level error */
  internal,
  /** Other useful information about error */
  data) {
    if (!Number.isInteger(code)) throw new Error('"code" must be an integer.');
    if (!message || typeof message !== 'string') throw new Error('"message" must be a nonempty string.');
    super(message);

    _defineProperty(this, "code", void 0);

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "internal", void 0);

    this.code = code;
    this.data = data;
    this.internal = internal;
  }

}
/**
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 * @see https://eips.ethereum.org/EIPS/eip-1193
 */

class ProviderRpcError extends RpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(
  /**
   * Number error code
   * @see https://eips.ethereum.org/EIPS/eip-1193#error-standards
   */
  code,
  /** Human-readable string */
  message,
  /** Low-level error */
  internal,
  /** Other useful information about error */
  data) {
    if (!(Number.isInteger(code) && code >= 1000 && code <= 4999)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(code, message, internal, data);
  }

}
class AddChainError extends Error {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'AddChainError');

    _defineProperty(this, "message", 'Error adding chain');
  }

}
class ChainNotConfiguredError extends Error {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'ChainNotConfigured');

    _defineProperty(this, "message", 'Chain not configured');
  }

}
class ConnectorAlreadyConnectedError extends Error {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'ConnectorAlreadyConnectedError');

    _defineProperty(this, "message", 'Connector already connected');
  }

}
class ConnectorNotFoundError extends Error {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'ConnectorNotFoundError');

    _defineProperty(this, "message", 'Connector not found');
  }

}
class SwitchChainError extends ProviderRpcError {
  constructor(error) {
    super(4902, 'Error switching chain', error);

    _defineProperty(this, "name", 'SwitchChainError');
  }

}
class SwitchChainNotSupportedError extends Error {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'SwitchChainNotSupportedError');

    _defineProperty(this, "message", 'Switch chain not supported by connector');
  }

}
class UserRejectedRequestError extends ProviderRpcError {
  constructor(error) {
    super(4001, 'User rejected request', error);

    _defineProperty(this, "name", 'UserRejectedRequestError');
  }

}
class ResourceUnavailableError extends RpcError {
  constructor(error) {
    super(-32002, 'Resource unavailable', error);

    _defineProperty(this, "name", 'ResourceUnavailable');
  }

}

class Connector extends EventEmitter {
  /** Unique connector id */

  /** Connector name */

  /** Chains connector supports */

  /** Options to use with connector */

  /** Whether connector is usable */
  constructor(_ref) {
    let {
      chains = defaultChains,
      options
    } = _ref;
    super();

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "chains", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "ready", void 0);

    this.chains = chains;
    this.options = options;
  }

  getBlockExplorerUrls(chain) {
    var _chain$blockExplorers;

    const blockExplorer = (_chain$blockExplorers = chain.blockExplorers) === null || _chain$blockExplorers === void 0 ? void 0 : _chain$blockExplorers.default;
    if (Array.isArray(blockExplorer)) return blockExplorer.map(x => x.url);
    if (blockExplorer !== null && blockExplorer !== void 0 && blockExplorer.url) return [blockExplorer.url];
    return [];
  }

  isChainUnsupported(chainId) {
    return !this.chains.some(x => x.id === chainId);
  }

}

export { AddChainError as A, ConnectorAlreadyConnectedError as C, ProviderRpcError as P, ResourceUnavailableError as R, SwitchChainNotSupportedError as S, UserRejectedRequestError as U, _classPrivateMethodInitSpec as _, allChains as a, ConnectorNotFoundError as b, Connector as c, chain as d, chainId as e, defaultChains as f, defaultL2Chains as g, etherscanBlockExplorers as h, ChainNotConfiguredError as i, RpcError as j, SwitchChainError as k, _defineProperty as l, _classPrivateFieldInitSpec as m, normalizeChainId as n, _classPrivateMethodGet as o, _classPrivateFieldSet as p, _classPrivateFieldGet as q };
