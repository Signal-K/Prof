'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var React = require('react');
var reactEnv = require('@chakra-ui/react-env');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var useSafeLayoutEffect = utils.isBrowser ? React.useLayoutEffect : React.useEffect;
/**
 * React hook that tracks state of a CSS media query
 *
 * @param query the media query to match
 * @param defaultValues the default values to match
 */

function useMediaQuery(query, defaultValues) {
  var env = reactEnv.useEnvironment();
  var queries = Array.isArray(query) ? query : [query];
  var defaults = Array.isArray(defaultValues) ? defaultValues : [defaultValues];
  defaults = defaults.filter(function (v) {
    return v != null;
  });

  var _useState = React.useState(function () {
    return queries.map(function (query, index) {
      var _defaults$index;

      return {
        media: query,
        matches: (_defaults$index = defaults[index]) != null ? _defaults$index : false
      };
    });
  }),
      value = _useState[0],
      setValue = _useState[1];

  useSafeLayoutEffect(function () {
    // set initial matches
    setValue(queries.map(function (query) {
      return {
        media: query,
        matches: env.window.matchMedia(query).matches
      };
    }));
    var mql = queries.map(function (query) {
      return env.window.matchMedia(query);
    });

    var handler = function handler(evt) {
      setValue(function (prev) {
        return prev.slice().map(function (item) {
          if (item.media === evt.media) return _extends({}, item, {
            matches: evt.matches
          });
          return item;
        });
      });
    };

    mql.forEach(function (mql) {
      if (utils.isFunction(mql.addListener)) mql.addListener(handler);else mql.addEventListener("change", handler);
    });
    return function () {
      mql.forEach(function (mql) {
        if (utils.isFunction(mql.removeListener)) mql.removeListener(handler);else mql.removeEventListener("change", handler);
      });
    };
  }, []);
  return value.map(function (item) {
    return item.matches;
  });
}

/**
 * Visibility
 *
 * React component to control the visibility of its
 * children based on the current breakpoint
 */
var Visibility = function Visibility(props) {
  var breakpoint = props.breakpoint,
      hide = props.hide,
      children = props.children;

  var _useMediaQuery = useMediaQuery(breakpoint),
      show = _useMediaQuery[0];

  var isVisible = hide ? !show : show;
  var rendered = isVisible ? children : null;
  return rendered;
};

var Hide = function Hide(props) {
  var children = props.children;
  var query = useQuery(props);
  return /*#__PURE__*/React__namespace.createElement(Visibility, {
    breakpoint: query,
    hide: true
  }, children);
};

if (utils.__DEV__) {
  Hide.displayName = "Hide";
}

var Show = function Show(props) {
  var children = props.children;
  var query = useQuery(props);
  return /*#__PURE__*/React__namespace.createElement(Visibility, {
    breakpoint: query
  }, children);
};

if (utils.__DEV__) {
  Show.displayName = "Show";
}

var getBreakpoint = function getBreakpoint(theme, value) {
  return utils.memoizedGet(theme, "breakpoints." + value, value);
};

function useQuery(props) {
  var _props$breakpoint = props.breakpoint,
      breakpoint = _props$breakpoint === void 0 ? "" : _props$breakpoint,
      below = props.below,
      above = props.above;
  var theme = system.useTheme();
  var bpBelow = getBreakpoint(theme, below);
  var bpAbove = getBreakpoint(theme, above);
  var query = breakpoint;

  if (bpBelow) {
    query = "(max-width: " + bpBelow + ")";
  } else if (bpAbove) {
    query = "(min-width: " + bpAbove + ")";
  }

  return query;
}

/**
 * React hook used to get the user's animation preference.
 */

function usePrefersReducedMotion() {
  var _useMediaQuery = useMediaQuery("(prefers-reduced-motion: reduce)"),
      prefersReducedMotion = _useMediaQuery[0];

  return prefersReducedMotion;
}
/**
 * React hook for getting the user's color mode preference.
 */

function useColorModePreference() {
  var _useMediaQuery2 = useMediaQuery(["(prefers-color-scheme: light)", "(prefers-color-scheme: dark)"]),
      isLight = _useMediaQuery2[0],
      isDark = _useMediaQuery2[1];

  if (isLight) return "light";
  if (isDark) return "dark";
  return undefined;
}

/**
 * React hook used to get the current responsive media breakpoint.
 *
 * @param [defaultBreakpoint="base"] default breakpoint name
 * (in non-window environments like SSR)
 *
 * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)
 * to get the default breakpoint value from the user-agent
 */

function useBreakpoint(defaultBreakpoint // default value ensures SSR+CSR consistency
) {
  var _breakpoints$index$br, _breakpoints$index;

  if (defaultBreakpoint === void 0) {
    defaultBreakpoint = "base";
  }

  var theme = system.useTheme();

  var breakpoints = theme.__breakpoints.details.map(function (_ref) {
    var minMaxQuery = _ref.minMaxQuery,
        breakpoint = _ref.breakpoint;
    return {
      breakpoint: breakpoint,
      query: minMaxQuery.replace("@media screen and ", "")
    };
  });

  var values = useMediaQuery(breakpoints.map(function (bp) {
    return bp.query;
  }), breakpoints.map(function (bp) {
    return bp.breakpoint === defaultBreakpoint;
  }));
  var index = values.findIndex(function (value) {
    return value == true;
  });
  return (_breakpoints$index$br = (_breakpoints$index = breakpoints[index]) == null ? void 0 : _breakpoints$index.breakpoint) != null ? _breakpoints$index$br : defaultBreakpoint;
}

function getClosestValue(values, breakpoint, breakpoints) {
  if (breakpoints === void 0) {
    breakpoints = utils.breakpoints;
  }

  var index = Object.keys(values).indexOf(breakpoint);

  if (index !== -1) {
    return values[breakpoint];
  }

  var stopIndex = breakpoints.indexOf(breakpoint);

  while (stopIndex >= 0) {
    var key = breakpoints[stopIndex];

    if (values[key] != null) {
      index = stopIndex;
      break;
    }

    stopIndex -= 1;
  }

  if (index !== -1) {
    var _key = breakpoints[index];
    return values[_key];
  }

  return undefined;
}

/**
 * React hook for getting the value for the current breakpoint from the
 * provided responsive values object.
 *
 * @param values
 * @param [defaultBreakpoint] default breakpoint name
 * (in non-window environments like SSR)
 *
 * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)
 * to get the default breakpoint value from the user-agent
 *
 * @example
 * const width = useBreakpointValue({ base: '150px', md: '250px' })
 */

function useBreakpointValue(values, defaultBreakpoint) {
  var _theme$__breakpoints;

  var breakpoint = useBreakpoint(defaultBreakpoint);
  var theme = system.useTheme();
  if (!breakpoint) return undefined;
  /**
   * Get the sorted breakpoint keys from the provided breakpoints
   */

  var breakpoints = Array.from(((_theme$__breakpoints = theme.__breakpoints) == null ? void 0 : _theme$__breakpoints.keys) || []);
  var obj = utils.isArray(values) ? utils.fromEntries(Object.entries(utils.arrayToObjectNotation(values, breakpoints)).map(function (_ref) {
    var key = _ref[0],
        value = _ref[1];
    return [key, value];
  })) : values;
  return getClosestValue(obj, breakpoint, breakpoints);
}

exports.Hide = Hide;
exports.Show = Show;
exports.useBreakpoint = useBreakpoint;
exports.useBreakpointValue = useBreakpointValue;
exports.useColorModePreference = useColorModePreference;
exports.useMediaQuery = useMediaQuery;
exports.usePrefersReducedMotion = usePrefersReducedMotion;
exports.useQuery = useQuery;
